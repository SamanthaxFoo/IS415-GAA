{
  "hash": "07b207a603a5015edd220a39e54f1f06",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 1\"\nsubtitle: \"Geospatial Data Wrangling with R!\"\nauthor: \"Foo Jia Yi Samantha\"\ndate-modified: 08/16/2024\ndate: 08/16/2024\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n```{=html}\n<button>Hands-on Exercise</button> <button>R</button> <button>sf</button> <button>ggplot2</button>\n```\n\n## 1. Getting Started\n\nIn this hands-on exercise, I will be performing geospatial data science tasks in R by using the **sf** and **tidyverse** R packages. By the end of this hands-on exercise, I would have acquired the following competencies:\n\n-   installing and loading sf and tidyverse packages into R environment,\n-   importing geospatial data by using appropriate functions of sf package,\n-   importing aspatial data by using appropriate function of readr package,\n-   exploring the content of simple feature data frame by using appropriate Base R and sf functions,\n-   assigning or transforming coordinate systems by using using appropriate sf functions,\n-   converting an aspatial data into a sf data frame by using appropriate function of sf package,\n-   performing geoprocessing tasks by using appropriate functions of sf package,\n-   performing data wrangling tasks by using appropriate functions of dplyr package and\n-   performing Exploratory Data Analysis (EDA) by using appropriate functions from ggplot2 package.\n\n## 2. Let's Set Up!\n\n### 2.1 Data Acquisition\n\nData are key to data analytics including geospatial analytics. Hence, before analysing, we need to assemble the necessary data. With that said, I have extracted the data sets from the following four sources:\n\n-   Master Plan 2014 Subzone Boundary (Web) from [data.gov.sg](https://data.gov.sg/)\n-   Pre-Schools Location from [data.gov.sg](https://data.gov.sg/)\n-   Cycling Path from [LTADataMall](https://www.mytransport.sg/content/mytransport/home/dataMall.html)\n-   Latest version of Singapore Airbnb listing data from [Inside Airbnb](http://insideairbnb.com/get-the-data.html)\n\n> I will be tapping on these vastly available, public data from the government and private sectors for future exercises ahead!\n\n### 2.2 Set Up the Folders\n\nThis is the file structure for containing the data files that I have extracted in the previous step. The `Hands-on_Ex1` folder consists of a `data` sub-folder, and is further separated by the `geospatial` and `aspatial` folders.\n\n![](/_site/images/Hands-on_Ex1_Data.JPG){fig-align=\"center\" width=\"700\"}\n\n### 2.3 Installing R Packages\n\nIn this exercise, I will be using these two R packages\n\n-   **sf** for importing, managing, and processing geospatial data, and\n-   **tidyverse** for performing data science tasks such as importing, wrangling and visualising data.\n\nTidyverse consists of a family of R packages. In this hands-on exercise, the following packages will be used:\n\n-   **readr** for importing csv data,\n-   **readxl** for importing Excel worksheet,\n-   **tidyr** for manipulating data,\n-   **dplyr** for transforming data, and\n-   **ggplot2** for visualising data\n\nWith that said, I installed the required packages using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tidyverse)\n```\n:::\n\n\n> **`p_load`** is a function of the [**pacman**](https://github.com/trinker/pacman) package that is used to install and load sf and tidyverse packages into our R environment.\n\n## **3. Importing Geospatial Data into R**\n\nIn this section, I will import the following geospatial data into R by using [*st_read()*](https://r-spatial.github.io/sf/reference/st_read.html) of the **sf** package:\n\n-   `MP14_SUBZONE_WEB_PL`: a polygon feature layer in ESRI shapefile format,\n-   `CyclingPath`: a line feature layer in ESRI shapefile format, and\n-   `PreSchool`: a point feature layer in kml file format.\n\n### 3.1 **Importing [Polygon]{.underline} Feature Data in .shp Format**\n\nThe code chunk below uses¬†*st_read()*¬†function of¬†**sf**¬†package to import¬†`MP14_SUBZONE_WEB_PL`¬†shapefile (.shp) into R as a polygon feature data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz = st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\SamanthaxFoo\\IS415-GAA\\Hands-on_Ex\\Hands-on_Ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\n> üîé **Observations:** the **`mpsz`** simple feature data frame contains **323** multipolygon features, **15** fields and is in the¬†**SVY21** projected coordinates system.\n\n> üí° **Note:** **`dsn`** defines folder path and **`layer`** defines file name (AKA a shapefile, no need any extension like .shp)\n\n### 3.2 **Importing [Polyline]{.underline} Feature Data in .shp Format**\n\nThe code chunk below imports¬†`CyclingPath`¬†shapefile (.shp) into R as a polyline feature data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncyclingpath = st_read(dsn = \"data/geospatial\", \n                         layer = \"CyclingPathGazette\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `CyclingPathGazette' from data source \n  `C:\\SamanthaxFoo\\IS415-GAA\\Hands-on_Ex\\Hands-on_Ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3138 features and 2 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 11854.32 ymin: 28347.98 xmax: 42644.17 ymax: 48948.15\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\n> üîé **Observations:** the **`cyclingpath`** linestring feature data frame contains **3138** features and **2** fields and it is in the¬†**SVY21** projected coordinates system.\n\n### 3.3 **Importing GIS [Point]{.underline} Feature Data in .kml Format**\n\nThe code chunk below imports¬†`PreSchoolsLocation.kml` kml format into R as a point feature data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreschool = st_read(\"data/geospatial/PreSchoolsLocation.kml\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `C:\\SamanthaxFoo\\IS415-GAA\\Hands-on_Ex\\Hands-on_Ex1\\data\\geospatial\\PreSchoolsLocation.kml' \n  using driver `KML'\nSimple feature collection with 2290 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6878 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n> üîé **Observations:** the `PreSchoolsLocation.kml` point feature data frame contains **2290** point features, **2** fields and is in the¬†**WGS84**¬†projected coordinates\n\n## 4. Importing Aspatial Data into R\n\n### 4.1 Importing Aspatial Data\n\nNotice that the¬†`listings`¬†data set is in **csv** file format. Instead of **`st_read()`**, we'll use **`read_csv()`**¬†from the **readr**¬†package to import¬†`listings.csv`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlistings <- read_csv(\"data/aspatial/listings.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 3540 Columns: 18\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \",\"\nchr   (6): name, host_name, neighbourhood_group, neighbourhood, room_type, l...\ndbl  (11): id, host_id, latitude, longitude, price, minimum_nights, number_o...\ndate  (1): last_review\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n> This outputs an R object called¬†`listings`¬†which is a¬†[tibble data frame](https://tibble.tidyverse.org/).\n\nLet's take a peak into our `listings` tibble data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(listings)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3,540\nColumns: 18\n$ id                             <dbl> 71609, 71896, 71903, 275343, 275344, 28‚Ä¶\n$ name                           <chr> \"Ensuite Room (Room 1 & 2) near EXPO\", ‚Ä¶\n$ host_id                        <dbl> 367042, 367042, 367042, 1439258, 143925‚Ä¶\n$ host_name                      <chr> \"Belinda\", \"Belinda\", \"Belinda\", \"Kay\",‚Ä¶\n$ neighbourhood_group            <chr> \"East Region\", \"East Region\", \"East Reg‚Ä¶\n$ neighbourhood                  <chr> \"Tampines\", \"Tampines\", \"Tampines\", \"Bu‚Ä¶\n$ latitude                       <dbl> 1.34537, 1.34754, 1.34531, 1.29015, 1.2‚Ä¶\n$ longitude                      <dbl> 103.9589, 103.9596, 103.9610, 103.8081,‚Ä¶\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat‚Ä¶\n$ price                          <dbl> NA, 80, 80, 50, 50, NA, 85, 65, 45, 54,‚Ä¶\n$ minimum_nights                 <dbl> 92, 92, 92, 180, 180, 92, 92, 180, 180,‚Ä¶\n$ number_of_reviews              <dbl> 19, 24, 46, 20, 16, 12, 131, 17, 5, 60,‚Ä¶\n$ last_review                    <date> 2020-01-17, 2019-10-13, 2020-01-09, 20‚Ä¶\n$ reviews_per_month              <dbl> 0.12, 0.15, 0.29, 0.15, 0.11, 0.08, 0.8‚Ä¶\n$ calculated_host_listings_count <dbl> 6, 6, 6, 49, 49, 6, 7, 49, 49, 6, 7, 7,‚Ä¶\n$ availability_365               <dbl> 89, 148, 90, 62, 0, 88, 365, 0, 0, 365,‚Ä¶\n$ number_of_reviews_ltm          <dbl> 0, 0, 0, 0, 2, 0, 0, 1, 1, 1, 0, 0, 0, ‚Ä¶\n$ license                        <chr> NA, NA, NA, \"S0399\", \"S0399\", NA, NA, \"‚Ä¶\n```\n\n\n:::\n:::\n\n\n> üîé **Observations:** there are 3540 rows and 18 columns (not features and fields like in our simple data feature frame!)\n\n> üí° **Note:** we'll be using the¬†`latitude`¬†and¬†`longitude`¬†fields in the next phase. These fields appear to be adopting the **WGS84 geographic** coordinate system.\n\n### 4.2 Converting Aspatial Data\n\nNext, we'll convert `listing` (a non-geospatial tabular data frame) into a **simple feature** data frame by using **`st_as_sf()`** from the **sf** package.\n\n> üí° **Note:** a non-simple feature data frame will simply not have a \"geometry\" column. Use **`class(listings)`** as a simple test - if it outputs data.frame, tbl_df, tbl, etc and no `sf`, then it's not a simple feature data frame!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlistings_sf <- st_as_sf(listings, coords = c(\"longitude\", \"latitude\"), crs=4326) %>% st_transform(crs = 3414)\n```\n:::\n\n\n::: panel-tabset\n## coords\n\nIndicates the column name of the x-coordinates, followed by that of the y-coordinates.\n\n## crs\n\nIndicates the coordinates system in epsg format (more info: [epsg.io](https://epsg.io/))\n\n-   [EPSG: 4326](https://epsg.io/4326) is **WGS84** Geographic Coordinate System\n-   [EPSG: 3414](https://epsg.io/3414) is Singapore **SVY21** Projected Coordinate System\n\n## %\\>%\n\nTo nest *st_transform()* and transform the newly created simple feature data frame into SVY21 Projected Coordinate System\n:::\n\nThis gives us the new simple feature data frame,¬†`listings_sf`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(listings_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3,540\nColumns: 17\n$ id                             <dbl> 71609, 71896, 71903, 275343, 275344, 28‚Ä¶\n$ name                           <chr> \"Ensuite Room (Room 1 & 2) near EXPO\", ‚Ä¶\n$ host_id                        <dbl> 367042, 367042, 367042, 1439258, 143925‚Ä¶\n$ host_name                      <chr> \"Belinda\", \"Belinda\", \"Belinda\", \"Kay\",‚Ä¶\n$ neighbourhood_group            <chr> \"East Region\", \"East Region\", \"East Reg‚Ä¶\n$ neighbourhood                  <chr> \"Tampines\", \"Tampines\", \"Tampines\", \"Bu‚Ä¶\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat‚Ä¶\n$ price                          <dbl> NA, 80, 80, 50, 50, NA, 85, 65, 45, 54,‚Ä¶\n$ minimum_nights                 <dbl> 92, 92, 92, 180, 180, 92, 92, 180, 180,‚Ä¶\n$ number_of_reviews              <dbl> 19, 24, 46, 20, 16, 12, 131, 17, 5, 60,‚Ä¶\n$ last_review                    <date> 2020-01-17, 2019-10-13, 2020-01-09, 20‚Ä¶\n$ reviews_per_month              <dbl> 0.12, 0.15, 0.29, 0.15, 0.11, 0.08, 0.8‚Ä¶\n$ calculated_host_listings_count <dbl> 6, 6, 6, 49, 49, 6, 7, 49, 49, 6, 7, 7,‚Ä¶\n$ availability_365               <dbl> 89, 148, 90, 62, 0, 88, 365, 0, 0, 365,‚Ä¶\n$ number_of_reviews_ltm          <dbl> 0, 0, 0, 0, 2, 0, 0, 1, 1, 1, 0, 0, 0, ‚Ä¶\n$ license                        <chr> NA, NA, NA, \"S0399\", \"S0399\", NA, NA, \"‚Ä¶\n$ geometry                       <POINT [m]> POINT (41972.5 36390.05), POINT (‚Ä¶\n```\n\n\n:::\n:::\n\n\n> üîé **Observations:**\n>\n> Notice that a new column called¬†`geometry`¬†has been added into the data frame. On the other hand, the¬†`longitude`¬†and¬†`latitude`¬†columns have been removed from the data frame.\n\n## 5. Exploring Contents of a Simple Feature Data Frame\n\nThere are **3 ways** to explore the contents of a simple feature data frame like **`mpsz`**!\n\n### 5.1 Using *st_geometry()*\n\nThe sf data.frame contains a **geometry** column, that is a list of class `sfc`. We can retrieve the geometry list-column in this case by `mpsz$geom` or `mpsz[[1]]`, but the more general way uses¬†**`st_geometry()`**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Retrieve geometry column\nst_geometry(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n```\n\n\n:::\n:::\n\n\n> üîé **Observations:** This `MP14_SUBZONE_WEB_PL` file consists of **323 features,** consisting of multipolygon features.\n\n### 5.2 Using *glimpse()*\n\nWe use **`glimpse()`** from the **dplyr** package to understand the data type of each fields.\n\nE.g.¬†`FMEL-UPD_D`¬†field is in¬†**date**¬†data type and¬†`X_ADDR`,¬†`Y_ADDR`,¬†`SHAPE_L`¬†and¬†`SHAPE_AREA`¬†fields are in **double-precision values**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get data types\nglimpse(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, ‚Ä¶\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, ‚Ä¶\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL‚Ä¶\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",‚Ä¶\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",‚Ä¶\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",‚Ä¶\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",‚Ä¶\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT‚Ä¶\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",‚Ä¶\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",‚Ä¶\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05‚Ä¶\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,‚Ä¶\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,‚Ä¶\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,‚Ä¶\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103‚Ä¶\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (‚Ä¶\n```\n\n\n:::\n:::\n\n\n> üîé **Observations:** This `MP14_SUBZONE_WEB_PL` file consists of **323 rows** and **16 columns** with datatypes ranging from integers, characters, date and doubles.\n\n### 5.3 Using *head()*\n\nWe use **`head()`** from the **base R** package to get the full information of the feature object **`mpsz`**. The `n` value indicates the no. of rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display top 5 rows of the feature object\nhead(mpsz, n=5)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n```\n\n\n:::\n:::\n\n\n> üîé **Observations:** We can notice that the `MP14_SUBZONE_WEB_PL` file consists of **5 features** and **15 fields,** with the top 5 rows per column.\n\n## 6. Plotting the Geospatial Data\n\nIn geospatial data science, looking at feature information is not sufficient. We are also interested in visualising the geospatial features of the sf object, in which **`plot()`** will help with that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot multi-plot of all attributes\nplot(mpsz)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: plotting the first 9 out of 15 attributes; use max.plot = 15 to plot\nall\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n> The default plot of an sf object is a **multi-plot** of all attributes, up to a reasonable maximum as shown above.\n\nWe can, however, choose to plot the geometry only as such:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the geometry only\nplot(st_geometry(mpsz))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nOr, plot the sf object using a specific attribute\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot a specific attribute\nplot(mpsz[\"PLN_AREA_N\"])\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n> üí° **Note:**¬†**`plot()`**¬†is meant for plotting the geospatial object at a high level. For high cartographic quality plot, other R package such as `tmap` should be used.\n\n## 7. Working with Projection\n\n**What is \"map projection\"?:** it is an important property of geospatial data. In order to perform **geoprocessing** using two geospatial data, we need to ensure that both geospatial data are **projected using similar coordinate system.**\n\nIn this section, I project a simple feature data frame from one coordinate system to another coordinate system. The technical term of this process is called **projection transformation**.\n\n### **7.1 Assigning EPSG code to a simple feature data frame**\n\n**Define \"ESPG code\":** a unique identifier to represent coordinate systems.\n\nCommon issues when importing geospatial data into R : the coordinate system of the source data are either...\n\n1.  Missing (such as due to missing .proj for ESRI shapefile)\n2.  Wrongly assigned\n\nTo check the coordinate system of `mpsz` simple feature data frame, I'll use **`st_crs()`** from the **sf** package.\n\n*\\* crs = Coordinate Reference System*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check coordinate system\nst_crs(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n```\n\n\n:::\n:::\n\n\n> üîé **Observations** Notice the `mpsz` data is a **SVY21** projected coordinate system. However, the ESPG code is wrongly indicated as **9001** in the last few lines. The correct ESPG code for SVY21 should be **3114**. Thus, we'll assign the correct code as such.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assign new ESPG code\nmpsz3414 <- st_set_crs(mpsz, 3414)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check that crs has been updated to 3414\nst_crs(mpsz3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n\n### 7.2 Converting Data from Geographic to Projected Coordinate System\n\nRecall that the **geographic coordinate system (e.g., WGS84)** is not appropriate for analyses that involve distance/area. Hence, it's common for us to **transform the original data** to a **projected coordinate system**.\n\nLet's take a look at the **`preschool`** simple feature data frame. It shows that it is in the WGS84 coordinate system, i.e., geographic coordinate system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transform projection\nst_geometry(preschool)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGeometry set for 2290 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6878 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPOINT Z (103.8072 1.299333 0)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPOINT Z (103.826 1.312839 0)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPOINT Z (103.8409 1.348843 0)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPOINT Z (103.8048 1.435024 0)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPOINT Z (103.839 1.33315 0)\n```\n\n\n:::\n:::\n\n\nNow, we'll transform **`preschool`**'s coordinate system from geographic (WGS84) to projected (SVY21).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreschool3414 <- st_transform(preschool, crs = 3414)\n```\n:::\n\n\n> üîé **Observations:** Notice that the last row shows \"Projected CRS\" now\n\n## **8. Geoprocessing with sf Package**\n\nBesides providing functions to handling geospatial data (i.e.¬†importing, exporting, assigning projection, transforming projection etc), **sf** package also offers a wide range of **geoprocessing (also known as GIS analysis) functions**.\n\nIn this section, I perform two commonly-used geoprocessing functions, namely [buffering](https://www.gislounge.com/buffers-in-gis/) and point in polygon count.\n\n### **8.1 Buffering**\n\nüìù**The scenario:** The authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on both sides of the current cycling path. You are tasked to determine the extend of the land needed to be acquired and their total area.\n\n**üí°The solution:**\n\nFirstly, **`st_buffer()`** of the **sf** package is used to compute the 5-meter buffers around cycling paths\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuffer_cycling <- st_buffer(cyclingpath, dist = 5, nQuadSegs = 30)\n```\n:::\n\n\n> A higher **`nQuadSegs`** value results in a smoother and more accurate circular buffer. The default is `30.`\n\nThis is followed by calculating the area of the buffers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n```\n:::\n\n\nLastly, **`sum()`** of Base R will be used to derive the total land involved\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(buffer_cycling$AREA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2218855 [m^2]\n```\n\n\n:::\n:::\n\n\n### **8.2 Point-in-polygon count**\n\nüìù**The scenario:** A pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\n\n**üí°The solution:**\n\nFirstly, identify pre-schools located inside each Planning Subzone by using **`st_intersects()`**. Next, **`length()`** of Base R is used to calculate the no. of pre-schools that fall inside each planning subzone.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz3414$`PreSch Count`<- lengths(st_intersects(mpsz3414, preschool3414))\n```\n:::\n\n\nYou can check the summary statistics of the newly derived ***PreSch Count*** field by using **`summary()`** as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mpsz3414$`PreSch Count`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    0.00    4.00    7.09   10.00   72.00 \n```\n\n\n:::\n:::\n\n\nTo list the planning subzone with the most number of pre-school, **`top_n()`** of the **dplyr** package is used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_n(mpsz3414, 1, `PreSch Count`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 39655.33 ymin: 35966 xmax: 42940.57 ymax: 38622.37\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO     SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      189          2 TAMPINES EAST    TMSZ02      N   TAMPINES         TM\n     REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR SHAPE_Leng\n1 EAST REGION       ER 21658EAAF84F4D8D 2014-12-05 41122.55 37392.39   10180.62\n  SHAPE_Area                       geometry PreSch Count\n1    4339824 MULTIPOLYGON (((42196.76 38...           72\n```\n\n\n:::\n:::\n\n\nNext, I calculate the density of pre-school by planning subzone. I used **`st_area()`** of the **sf** package to derive the area of each planning subzone.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz3414$Area <- mpsz3414 %>%   st_area()\n```\n:::\n\n\nNext, I used **`mutate()`**of the **dplyr** package to compute the density by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz3414 <- mpsz3414 %>% mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)\n```\n:::\n\n\n## **9. Exploratory Data Analysis (EDA)**\n\nIn practice, many geospatial analytics start with Exploratory Data Analysis. In this section, I will tap on **`ggplot2()`** functions to create functional yet transparent statistical graphs for EDA purposes.\n\nFirstly, we will plot a histogram to reveal the distribution of `PreSch Density`. Conventionally, **`hist()`** of R Graphics will be used as shown.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(mpsz3414$`PreSch Density`)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nAlthough the syntax is very easy to use, the output is currently far from meeting publication quality. Furthermore, **`hist()`** function has limited room for further customisation.\n\nIn the code chunk below, appropriate **`ggplot2()`** functions will be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning sub-zones with a single pre-school, on the other hand, \\nthere are two planning sub-zones with at least 20 pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nUsing ggplot2 method, I plot a scatterplot showing the relationship between Pre-school Density and Pre-school Count.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=mpsz3414, \n       aes(y = `PreSch Count`, \n           x= as.numeric(`PreSch Density`)))+\n  geom_point(color=\"black\", \n             fill=\"light blue\") +\n  xlim(0, 40) +\n  ylim(0, 40) +\n  labs(title = \"\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Pre-school count\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}