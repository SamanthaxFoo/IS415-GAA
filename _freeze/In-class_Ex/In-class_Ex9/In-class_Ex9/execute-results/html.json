{
  "hash": "62de6377c5bdcfe359bb67d494ce7b27",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class Exercise 9\"\nsubtitle: \"Geographical Segmentation with Spatially Constrained Clustering Techniques\"\nauthor: \"Foo Jia Yi Samantha\"\ndate-modified: 10/21/2024\ndate: 10/21/2024\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n```{=html}\n<button>Hands-on Exercise</button> <button>R</button> <button>coorplot</button> <button>ggpubr</button> <button>heatmaply</button><button>ClustGeo</button>\n```\n\n## 1. Overview\n\nIn this hands-on exercise, I will learn more on performing how to delineate homogeneous region by using geographically referenced multivariate data. There are two major analysis, namely:\n\n-   hierarchical cluster analysis; and\n\n-   spatially constrained cluster analysis.\n\n### **1.1 Learning Outcome**\n\nBy the end of this hands-on exercise, I aim to accomplish the following learning:\n\n-   to convert GIS polygon data into R’s simple feature data.frame by using appropriate functions of **sf** package of R;\n\n-   to convert simple feature data.frame into R’s SpatialPolygonDataFrame object by using appropriate **sf** of package of R;\n\n-   to perform custer analysis by using *hclust()* of Base R;\n\n-   to perform spatially constrained cluster analysis using *skater()* of Base R; and\n\n-   to visualise the analysis output by using **ggplot2** and **tmap** package.\n\n### 1.2 Installing Required Packages\n\nBefore we get started, it is important for us to install the necessary R packages into R and launch these R packages into R environment.\n\nThe R packages needed for this exercise are as follows:\n\n-   Spatial data handling\n\n    -   **sf**, **rgdal** and **spdep**\n\n-   Attribute data handling\n\n    -   **tidyverse**, especially **readr**, **ggplot2** and **dplyr**\n\n-   Choropleth mapping\n\n    -   **tmap**\n\n-   Multivariate data visualisation and analysis\n\n    -   **coorplot**, **ggpubr**, and **heatmaply**\n\n-   Cluster analysis\n\n    -   **cluster**\n\n    -   **ClustGeo**\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n:::\n\n\n::: callout-note\nWith **tidyverse**, we do not have to install **readr**, **ggplot2** and **dplyr** packages separately. In fact, **tidyverse** also installs other very useful R packages such as **tidyr**.\n:::\n\n### 1.3 Preparing the Datasets\n\nTwo data sets will be used in this study. They are:\n\n-   **Myanmar Township Boundary Data** (i.e. *myanmar_township_boundaries*) : This is a GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.\n\n-   ***Shan-ICT.csv*****:** This is an extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.\n\nBoth data sets are download from [Myanmar Information Management Unit (MIMU)](http://themimu.info/)\n\n### 2.2 Import Data and Set Up Folders\n\nTwo data sets I will be using in this study are as follows:\n\n-   **Shan_sf.Rds:** Myanmar Township Boundary Data (i.e. *myanmar_township_boundaries*) : This is a GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.\n\n-   ***Shan_ICT.Rds***: This is an extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.\n\n-   ***shan_sf_cluster.Rds***: this variable combines the shan_ict and shan_sf dataframes which leads to some redundant variables like dt.x\n\nBoth data sets are download from [Myanmar Information Management Unit (MIMU)](http://themimu.info/)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict <- readRDS(file = \"data/rds/shan_ict.Rds\")\nshan_sf <- readRDS(file = \"data/rds/shan_sf.Rds\")\nHsan_sf_cluster <- readRDS(file = \"data/rds/shan_sf_cluster.Rds\")\n```\n:::\n\n\nThe imported InfoComm variables are extracted from **The 2014 Myanmar Population and Housing Census Myanmar**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's inspect\nglimpse(Hsan_sf_cluster)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 55\nColumns: 19\n$ ST            <chr> \"Shan (North)\", \"Shan (South)\", \"Shan (South)\", \"Shan (S…\n$ ST_PCODE      <chr> \"MMR015\", \"MMR014\", \"MMR014\", \"MMR014\", \"MMR015\", \"MMR01…\n$ TS            <chr> \"Mongmit\", \"Pindaya\", \"Ywangan\", \"Pinlaung\", \"Mabein\", \"…\n$ TS_PCODE      <chr> \"MMR015017\", \"MMR014006\", \"MMR014007\", \"MMR014009\", \"MMR…\n$ TT_HOUSEHOLDS <dbl> 13652, 17544, 18348, 25504, 8632, 41341, 20084, 25957, 3…\n$ RADIO         <dbl> 3907, 7324, 8890, 5908, 3880, 11607, 6399, 10048, 11257,…\n$ TV            <dbl> 7565, 8862, 4781, 13816, 6117, 25285, 10762, 16353, 1765…\n$ LLPHONE       <dbl> 482, 348, 219, 728, 628, 1739, 800, 818, 1239, 1123, 310…\n$ MPHONE        <dbl> 3559, 2849, 2207, 6363, 3389, 16900, 4315, 8321, 10409, …\n$ COMPUTER      <dbl> 166, 226, 81, 351, 142, 1225, 381, 565, 508, 878, 2028, …\n$ INTERNET      <dbl> 321, 136, 152, 737, 165, 1741, 316, 556, 1216, 936, 2020…\n$ RADIO_PR      <dbl> 286.18517, 417.46466, 484.52147, 231.64994, 449.49027, 2…\n$ TV_PR         <dbl> 554.1313, 505.1300, 260.5734, 541.7189, 708.6423, 611.62…\n$ LLPHONE_PR    <dbl> 35.306182, 19.835841, 11.935906, 28.544542, 72.752549, 4…\n$ MPHONE_PR     <dbl> 260.69440, 162.39170, 120.28559, 249.49028, 392.60890, 4…\n$ COMPUTER_PR   <dbl> 12.159391, 12.881897, 4.414650, 13.762547, 16.450417, 29…\n$ INTERNET_PR   <dbl> 23.513038, 7.751938, 8.284282, 28.897428, 19.114921, 42.…\n$ CLUSTER       <chr> \"1\", \"1\", \"2\", \"1\", \"3\", \"3\", \"1\", \"3\", \"3\", \"3\", \"4\", \"…\n$ geometry      <MULTIPOLYGON [°]> MULTIPOLYGON (((96.96001 23..., MULTIPOLYGO…\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Observations\"}\nThe resulting output of the `shan_ict_cluster` variabble includes attribute data as well as geometry variables which consists of multipolygons. This *simple feature* output has a total of **55** **rows** and **19 columns,** which has been tidied for our in-class exercise.\n:::\n\n## 2. Conventional Hierarchical Clustering\n\n::: panel-tabset\n## Hierarchical Clustering\n\nTake note that the **hclust()** function must first be used before the **k** value can be selected. In this case, hclust_ward is not a simple output data, but a hierarchical clustering object class. We have used **k = 6** to output the number of groups based on our analysis of the optimal k-value in the chart\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproxmat <- dist(shan_ict, method = \"euclidean\")\nhclust_ward <- hclust(proxmat, method = \"ward.D\")\ngroups <- as.factor(cutree(hclust_ward, k = 6))\n```\n:::\n\n\n\\*Recall our analysis of the optimal k-value as discovered in Hands-on Exercise 9\n\n![](images/clipboard-3412230221.png){width=\"560\" height=\"400\"}\n\n## Append to geospatial data\n\nWe do not use left_join() since we don't want to sort the sequence. Beisdes using `as.matrix()`, we can also convert it into a data table or tibble format. Note that using variables like **TS.x** is not user-friendly and should be renamed as shown. We will also drop columns not relevant to us, e.g. columns 3 to 4, and 7 to 9.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_cluster <- cbind(shan_sf,\n                         as.matrix(groups)) %>%\n  rename('CLUSTER' = 'as.matrix.groups.') %>%\n  select(-c(3:4, 7:9)) %>%\n  rename(TS = TS.x)\n```\n:::\n\n\n## The Dendrogram\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hclust_ward, cex = 0.6)\nrect.hclust(hclust_ward, k = 6, border = 2:5)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex9_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## Cluster Map\n\nIn Chapter 2 of Prof Kam's book and our in-class ex 2, we used 1) `qtm()` and 2) call `tm.shape()` and other functions like `tm_fill()`. However, we will use the **`QTM()`** function of the **tmap package** which serves as a fast way of generating the map for us.\n\nNote that the default number of colours the `QTM()` function will classify to is 5 so any dataset with \\>5 categories should manually include the colours we need.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_cluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex9_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n:::\n\n## 3. Spatially Constrained Clustering\n\nIf the clustering values are close (attribute) and they are goegraphically close in terms of proximity, we form **spatially constrained clustering.** This form of clustering attempts to create more spatial homogeneity by using two methods...\n\n1.  **Skater**: a hard spatial classification method\n2.  **ClustGeo**: a soft spatial classification method\n\n### 3.1 SKATER Algorithm (Spatial 'k'luster Analysis by Tree Edge Removal)\n\nBy generating the clustering results, we assign a weight by adding the attribute value to the edges of each node, which aims to refine the clusters through rounds of iterations.\n\n#### 3.1.1 Computing Nearest Neighbours\n\nTo build our minimum spanning tree, we first calculate the number of neighbours each node has.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.nb <- poly2nb(shan_sf)\nsummary(shan.nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n```\n\n\n:::\n:::\n\n\n::: callout-note\nNote that we do not need to convert the data to **sp** since the two previous versions of SPDEP can accept **sf** variables!\n:::\n\n#### 3.1.2 Visualise the Neighbours\n\nHere we plot the nodes and their connecting edges to adjacent neighbours. It is worth noting that not all plots are relevant for us - Prof Kam suggests to think about what your end-users want to see and be selective of what your app should expose :)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- st_coordinates(\n  st_centroid(shan_sf))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: st_centroid assumes attributes are constant over geometries\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n     border=grey(.5))\nplot(shan.nb,\n     coords, \n     col=\"blue\", \n     add=TRUE)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex9_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n#### 3.1.3 Computing Minimum Spanning Tree\n\n**1) Calculate edge costs**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlcosts <- nbcosts(shan.nb, shan_ict)\n```\n:::\n\n\n**2) Incorporating these costs into a weights object**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.w <- nb2listw(shan.nb,\n                   lcosts,\n                   style = 'B')\n\nsummary(shan.w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n\nWeights style: B \nWeights constants summary:\n   n   nn       S0       S1        S2\nB 55 3025 76267.65 58260785 522016004\n```\n\n\n:::\n:::\n\n\n**3) Computing MST**\n\nThe `mstree()` function is of the **spdep** package which combines the weight matrix and proximity matrix together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.mst <- mstree(shan.w)\n```\n:::\n\n\nAfter computing the MST, we can check its class and dimension by using the code chunk below. It should return a list-object data format\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]      [,3]\n[1,]   26   34 140.95392\n[2,]   34   24 113.80917\n[3,]   34   16 119.86993\n[4,]   16   13 131.67061\n[5,]   13   28  92.79567\n[6,]   28   12  78.78999\n```\n\n\n:::\n:::\n\n\n**4) Visualise the MST**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), border=gray(.5))\nplot.mst(shan.mst, \n         coords,\n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex9_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n**5) Computing Spatially Constrained Clusters**\n\nNext, we will compute the spatially constrained cluster using [*skater()*](https://r-spatial.github.io/spdep/reference/skater.html) of **spdep** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclust6 <- spdep::skater(edges = shan.mst[,1:2], \n                 data = shan_ict, \n                 method = \"euclidean\", \n                 ncuts = 5)\n```\n:::\n\n\nThe result of the *skater()* is an object of class **skater**. We can examine its contents by using the code chunk below. As seen below, this is a list of 8 list items.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(clust6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 8\n $ groups      : num [1:55] 3 3 6 3 3 3 3 3 3 3 ...\n $ edges.groups:List of 6\n  ..$ :List of 3\n  .. ..$ node: num [1:22] 13 48 45 55 52 37 34 16 25 54 ...\n  .. ..$ edge: num [1:21, 1:3] 48 55 45 37 34 34 52 25 16 13 ...\n  .. ..$ ssw : num 3423\n  ..$ :List of 3\n  .. ..$ node: num [1:18] 47 27 53 38 42 15 41 51 43 32 ...\n  .. ..$ edge: num [1:17, 1:3] 53 15 42 38 41 51 15 27 15 43 ...\n  .. ..$ ssw : num 3759\n  ..$ :List of 3\n  .. ..$ node: num [1:11] 2 6 8 1 36 4 10 9 46 5 ...\n  .. ..$ edge: num [1:10, 1:3] 6 1 8 36 4 6 8 10 10 9 ...\n  .. ..$ ssw : num 1458\n  ..$ :List of 3\n  .. ..$ node: num [1:2] 44 20\n  .. ..$ edge: num [1, 1:3] 44 20 95\n  .. ..$ ssw : num 95\n  ..$ :List of 3\n  .. ..$ node: num 23\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n  ..$ :List of 3\n  .. ..$ node: num 3\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n $ not.prune   : NULL\n $ candidates  : int [1:6] 1 2 3 4 5 6\n $ ssto        : num 12613\n $ ssw         : num [1:6] 12613 10977 9962 9540 9123 ...\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:55] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n```\n\n\n:::\n:::\n\n\nWe are also able to check the cluster assignment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nccs6 <- clust6$groups\nccs6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 3 3 6 3 3 3 3 3 3 3 2 1 1 1 2 1 1 1 2 4 1 2 5 1 1 1 2 1 2 2 1 2 2 1 1 3 1 2\n[39] 2 2 2 2 2 4 1 3 2 1 1 1 2 1 2 1 1\n```\n\n\n:::\n:::\n\n\n::: callout-note\nThe most interesting component of this list structure is the groups vector containing the labels of the cluster to which each observation belongs (as before, the label itself is arbitary). This is followed by a detailed summary for each of the clusters in the edges.groups list. Sum of squares measures are given as ssto for the total and ssw to show the effect of each of the cuts on the overall criterion.\n:::\n\nWe can use as.factor() to encode our numerical data accordingly. Note that the cluster numbers will be sorted in ascending format by default as 1,2,3...5.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sp)\nplot(st_geometry(shan_sf), \n     border=gray(.5))\nplot(clust6, \n     coords, \n     cex.lab=.7,\n     groups.colors=c(\"red\",\"green\",\"blue\", \"brown\", \"pink\"),\n     cex.circles=0.005, \n     add=TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](In-class_Ex9_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nLastly, let us plot the map using the `qtm()` function of the **spdep** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups_mat <- as.matrix(clust6$groups)\nshan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(shan_sf_spatialcluster, \"SP_CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex9_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n### 3.2 ClustGeo Method\n\nThis is a soft classification where the user can manipulate and select specific interactions they desire, e.g. spatial interactions, where the user can choose specify a certain range.\n\n#### 3.2.1 Compute spatial distance matrix\n\nThe first step we should take is to utilise the `st_distance()` function of the **sf** package to compute the distance matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- st_distance(shan_sf, shan_sf)\ndistmat <- as.dist(dist)\n```\n:::\n\n\n::: callout-note\nThe fieldnames will be the destination while the row numbers are numbers. Hence, we keep the distance matri. Notice that `as.dist()` is used to convert the data frame into matrix.\n:::\n\n#### 3.2.2 Plotting Cluster Graphs\n\nNext, `choicealpha()` will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below. The 0.1 breaks interval will output a graph that will create intervals of 0.1\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncr <- choicealpha(proxmat, distmat, \n                  range.alpha = seq(0, 1, 0.1), \n                  K=6, graph = TRUE)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex9_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](In-class_Ex9_files/figure-html/unnamed-chunk-21-2.png){width=672}\n:::\n:::\n\n\n#### 3.2.3 Saving ClustGeo Output\n\nYou will want to save the output and await for user to click a button on the app before the app exposes the updated charts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.3)\ngroups <- as.factor(cutree(clustG, k=6))\nshan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_Gcluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex9_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n#### 3.2.4 Multivariate Visualisation\n\nggarray() is an extension of ggplot(). By using a ssimilar y-axis and facet-ing these plots in a row, we can easily visualise how each cluster might differ by ICT variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\nggparcoord(data = shan_sf_ngeo_cluster, \n           columns = c(17:21), \n           scale = \"globalminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of ICT Variables by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 30))\n```\n\n::: {.cell-output-display}\n![](In-class_Ex9_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n::: callout-note\nI made a realisation that we should use a `set.seed()` function to ensure that the cluster numbers do not change since it will inherently be generated differently for each run of the codes. E.g. cluster 1 can become cluster 2's patterns the next time we run the codes.\n:::\n",
    "supporting": [
      "In-class_Ex9_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}