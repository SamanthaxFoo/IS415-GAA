---
title: "Take-home Exercise 1"
subtitle: "Harnessing Geospatial Analytics to Uncover Armed Conflict Patterns in Myanmar"
author: "Foo Jia Yi Samantha"
date-modified: 09/06/2024
date: 09/06/2024
execute: 
  eval: true
  echo: true
  freeze: true
---

## **2. Let’s Set Up!**

### **2.1 Importing Libraries into R**

To carry out this exercise, I will be using the following R packages:

-   **sf**: a relatively new R package specially designed to import, manage and process vector-based geospatial data in R.
-   **spatstat**: has a wide range of useful functions for point pattern analysis. In this take-home exercise, it will be used to perform 1st- and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer.
-   **raster**: reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster). In this take-home exercise, it will be used to convert image output generate by spatstat into raster format.
-   **maptools**: provides a set of tools for manipulating geographic data. We mainly use it to convert Spatial objects into ppp format of spatstat.
-   **tmap**: provides functions for plotting cartographic quality static point patterns maps or interactive maps by using leaflet API.

Now, let’s install and load these packages in RStudio.

```{r}
pacman::p_load(sf, raster, spatstat, sparr, tmap, tidyverse)
```

### **2.2 Importing Data Sets into R**

Next, I will import the downloaded armed conflict data. For aspatial datasets like this*,* we will import into Rstudio using `read_csv()` function of the **readr** package.

```{r}
# Import armed conflict data
conflict_data <- read_csv("data/aspatial/2021-01-01-2024-06-30-Myanmar.csv")
```

::: {.callout-tip title="Observations"}
The `2021-01-01-2024-06-30-Myanmar.csv` dataset contains 87746 rows and 28 columns which indicates the presence of 87746 unique armed conflict events in Myanmar.
:::

After importing the dataset, we can inspect the dataset using the **`glimpse()`** function.

```{r}
# Inspect the conflict data
glimpse(conflict_data)
```

::: {.callout-tip title="Observations"}
The event_date field shows that it uses a character datatype instead of date - we will fix this later. Also, we can observe that the**`longitude`** and **`langitude`** fields appear to be adopting the **WGS84 geographic** coordinate system since they are in the -180/180 and -90/90 range respectively.
:::

I will also import the administrative boundary data into a simple features tibble data.frame using [*st_read()*](https://r-spatial.github.io/sf/reference/st_read.html) of the **sf** package. This function reads the shapefile data and returns an **`sf`** object that can be used for further analysis.

```{r}
# Import boundary data
boundary_sf <- st_read(dsn = "data/geospatial",layer = "mmr_polbnda_adm2_250k_mimu") %>% st_transform(crs = 32647)
```

::: {.callout-tip title="Observations"}
In the code above, the **`%>%`** operator is used to pass the output of `st_read()` directly to the **`st_transform()`** function. Since the dataset represents the Myanmar boundary, we need to assign the appropriate coordinate reference system, which is UTM zone 47N **(EPSG:32647),** east of Myanmar**.** The **`st_transform()`** function then converts the CRS of the **`sf`** object to EPSG:32647.
:::

In the code below, we can notice that the ESPG code has been updated to **32647**.

```{r}
# Check for changes
st_crs(boundary_sf)
```

Here, I will use the **`plot()`** function which plots the geometry of the **`sf`** object. The **`st_geometry()`** function is used to extract the geometry of the **`mpsz_sf`** object which includes the districts of Myanmar as shown below.

```{r}
par(mar = c(0,0,0,0))
plot(st_geometry(boundary_sf))
```

## 3. Data Wrangling

### 3.1 Fixing Incorrect Datatypes

Recall that the earlier inspection of the `conflict_data` tibble data frame revealed that the datatype indicated for event date is wrongly labelled as a character instead of a date format.

As such, let's convert the datatype to the correct 'date' format as shown below.

```{r}
# Convert the datatype for event_date
conflict_data$event_date <- as.Date(conflict_data$event_date, format = "%d %B %Y")

# Check for changes
head(conflict_data)
```

### 3.2 Adding new year_quarter column

We will want to create a new column to indicate the specific year and quarter for each conflict event since the spatial analysis will be done later in a quarterly manner.

```{r}
#| code-fold: true
#| code-summary: Extract year and quarter
conflict_data$year_quarter <- paste0(
  year(conflict_data$event_date), 
  " Q", 
  quarter(conflict_data$event_date)
)

# View the new data column
unique(conflict_data$year_quarter)
```

### 3.3 Fixing Duplicated Event ID in *conflict_data* Dataframe

As shown, there are presence of duplicates in our dataframe returned by the **`duplicated()`** function.

```{r}
# Check for duplicates
any(duplicated(conflict_data))
```

Based on the duplicated **event ID: MMR64313** for instance. We can observe the two records are of the **same** political violence event happening between **two** **actors** on 30/6/2024, between the People's Defense Force and Military Forces of Myanmar. Upon further research, these two actors are **opposing political parties** of Myanmar's ongoing conflict.

```{r}
# Inspect an instance of the duplciated event IDs
head(conflict_data,2)
```

::: {.callout-tip title="Reflection"}
**Should duplicated data be removed in this analysis?**

A **single event** (e.g. MMR64313) can have duplicated rows **with different actor1 values**, typically due to counterattacks from opposing sides, leading to different data entries into the **`conflict_data`** dataset.

Hence, I will **remove duplicated events** found in the **`conflict_data`** dataframe as long as the rows have the same event ID indicated.
:::

Here, I did another check to ensure there is **not more than 2 possible repeated event IDs** in the first 20 rows of **conflict_data**.

```{r}
#| code-fold: true
#| code-summary: Check duplicated events for first 20 rows
duplicate_counts_first_20 <- conflict_data %>%
  slice(1:20) %>%            
  group_by(event_id_cnty) %>% 
  summarize(count = n()) %>%  
  filter(count > 1)         

# View the result
print(duplicate_counts_first_20)
```

With that checked, I'll remove the duplicated rows with a repeated Event ID.

```{r}
#| code-fold: true
#| code-summary: Remove duplicated rows
# Retrieve data of duplicated rows
merged_duplicates <- conflict_data %>%
  filter(duplicated(event_id_cnty) | duplicated(event_id_cnty, fromLast = TRUE)) %>%
  arrange(event_id_cnty) %>%
  group_by(event_id_cnty) %>%
  summarize(
    actor2 = last(actor1),
    assoc_actor_2 = last(assoc_actor_1)
  )

conflict_data_no_duplicates <- conflict_data %>%
  filter(!duplicated(event_id_cnty))

# Update conflict_data dataframe with new columns
conflict_data <- conflict_data_no_duplicates %>%
  left_join(merged_duplicates, by = "event_id_cnty")

# View dataframe
print(head(conflict_data))
```

We can observe that there are no longer any duplicated event IDs in our **`conflict_data`** data frame.

```{r}
any(duplicated(conflict_data))
```

### 3.4 Converting Aspatial Data to Simple Feature Format

For the purpose of this exercise, we will want to integrate and analyse aspatial data in a geographic context. I'll do a check if **`conflict_data`** needs to be converted to a **sf data frame** - if it outputs anything else but `sf`, then it’s not a simple feature data frame!

```{r}
class(conflict_data)
```

::: {.callout-tip title="Observations"}
We can see that **`conflict_data`** is **not** a sf data frame. Since a non-simple feature data frame does not have a “geometry” column, we’ll need to convert **`conflict_data`** into a **simple feature** data frame
:::

We can convert **`conflict_data`** into a **simple feature** data frame by using **`st_as_sf()`** from the **sf** package. Addiitionally, we will also need to transform coordinate system from geographic **(ESPG: 4326)** to projected **(ESPG: 32647)** using **`st_transform()`**.

```{r}
# Convert to simple feature format
conflict_data_sf <- st_as_sf(conflict_data, coords = c("longitude", "latitude"), crs=4326) %>% st_transform(crs = 32647)

# Inspect the changes
glimpse(conflict_data_sf)
```

::: {.callout-tip title="Observations"}
Notice that a new column called `geometry` has been added into the data frame. On the other hand, the `longitude` and `latitude` columns have been removed from the data frame.
:::

We can further inspect the newly created 'geometry' column of **`conflict_data_sf`**

```{r}
# Retrieve geometry column
st_geometry(conflict_data_sf)
```

::: {.callout-tip title="Observations"}
It consists of **51,533 features** consisting of **point** **geometric features** where the underlying datum is in WGS 84 format.
:::

To ensure that the coordinate system is correctly updated, we can use the **`st_crs()`** function where we observe that the ESPG code is correctly indicated as **32647**.

```{r}
# Check CRS format
st_crs(conflict_data_sf)
```

### 3.5 Reduce Data File Size

In this section, I will reduce the current Myanmar armed conflict dataset as the time taken for computing the kernel density estimates can take up to 30 minutes long which is not computationally efficient.

#### **1) Remove 'Protests' and 'Riots' Event Types**

I will remove rows in the **`conflicts_data_sf`** dataset that don't focus on the four main event types (Battles, Explosion/Remote violence, Strategic developments, and Violence against civilians), as mentioned in the exercise brief.

```{r}
conflict_data_sf <- conflict_data_sf %>%
  filter(!(event_type %in% c("Protests", "Riots")))

unique(conflict_data_sf$event_type)
```

#### **2) Remove unused columns in boundary_sf**

As seen, there are **8 columns** in the simple feature data frame of **`boundary_sf`**.

```{r}
# Inspect first rows of data in boundary_sf
head(boundary_sf)
```

I will remove **'DT_MMR"** column as we already have the District Name in English in **`DT`** and won't require the district names in Myanmar Language. Next, we will remove the coded versions of **ST (state/region)** and **DT (district)** columns, namely **`ST_PCODE`** and **`DT_PCODE`**. Additionally, we won't need the **`PCode_V`** column since we will be dropping the PCODE column too.

```{r}
boundary_sf <- boundary_sf %>% dplyr::select('OBJECTID', 'ST', 'DT','geometry')
summary(boundary_sf)
```

#### **3) Remove unused columns in conflict_data**

I will also remove unnecessary columns of the **`conflict_data`** data frame that won't be used in our spatial analysis later.

```{r}
#| code-fold: true
#| code-summary: Remove unnecessary columns
conflict_data_sf <- conflict_data_sf %>%
  select(event_id_cnty, event_date, year_quarter, disorder_type, event_type, location, geometry, fatalities)

summary(conflict_data_sf)
```

Let's append **`conflict_data_sf`** with the columns of **`boundary_sf`** to assist our analysis later.

```{r}
# Link conflict event to its district region
conflict_data_sf <- st_join(conflict_data_sf, boundary_sf, join = st_intersects)
```

### 3.6 Converting Simple Features Data Frame into ppp Object

It is important that we convert **`conflict_data_sf`** (a simple feature data frame) into a **planer point pattern (ppp)** object format, since the **`spatstat`** package that we'll be using for the Spatial Point Pattern Analysis later is specifically designed for working with **ppp-formated** data. Additionally, I will begin with **categorising the ppp objects** into their **unique `year_quarter`** **category**.

```{r}
#| code-fold: true
#| code-summary: Create ppp objects based on year_quarter category
# Create an empty list to store the ppp objects
ppp_list <- list()

# Loop through each unique year_quarter category
for (yq in unique(conflict_data_sf$year_quarter)) {
  # Subset the data for the current year_quarter
  subset_data_sf <- conflict_data_sf %>% filter(year_quarter == yq)
  
  # Convert the subset to a ppp object
  subset_ppp <- as.ppp(subset_data_sf$geometry)
  
  # Add the ppp object to the list
  ppp_list[[yq]] <- subset_ppp
}

# Check list
ppp_list
```

We can visualise the spread of conflict events across each quarter from January 2021 to June 2024 using the **`plot()`** function as shown below.

```{r}
#| code-fold: true
#| code-summary: Visualise the spread of conflicts by year_quarter
# Ensure 'year_quarter' is a factor
conflict_data_sf$year_quarter <- as.factor(conflict_data_sf$year_quarter)

# Loop through each unique year_quarter and create separate plots
year_quarters <- unique(conflict_data_sf$year_quarter)

# Set up a grid layout for multiple plots (adjust 'mfrow' as needed)
par(mfrow = c(2,3))
par(mar = c(0,0,1,0))

# Loop through each year_quarter and plot
for (yq in year_quarters) {
  subset_data_sf <- conflict_data_sf[conflict_data_sf$year_quarter == yq, ]
  conflict_data_ppp <- as.ppp(subset_data_sf$geometry)
  
  # Plot each subset ppp object
  plot(conflict_data_ppp, main = paste("Year-Quarter:", yq))
}
```

::: {.callout-tip title="Observations"}
It is noticeable that there **conflict events have occured more frequently** since 2021 as points plotted on the graph have gotten darker across 2021 to 2024. We can also observe the **possibility of duplicated events** occurring from the darker spots in the plot, in which it appears more intense in Myanmar's central and west regions.
:::

### 3.7 Creating *owin* object

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area, that is Myanmar's boundary in this case. In **`spatstat`**, an object called **`owin`** is specially designed to represent this **polygonal region**.

The code chunk below is used to convert the **`boundary_data_sf`** simple feature data frame into an **`owin`** object of **`spatstat`**.

```{r}
# Convert to owin object
myanmar_owin <- as.owin(boundary_sf)

# Visualise the owin object
plot(myanmar_owin)
```

::: {.callout-tip title="Observations"}
From my observations, the **`as.owin()`** function converts the **`boundary_data_sf`** spatial boundary into a window object that represents the outer boundary of the spatial region and does not handle internal structures or districts we previously saw from the plot of **`boundary_data_sf`**`.`
:::

We can also take a quick look at the **`owin`** object properties as shown. I will be converting it to a data frame for the purposes of getting a quick glimpse of the object.

```{r}
# Summary info of owin object
owin_df <- as.data.frame(myanmar_owin)
print(head(owin_df))
```

### **3.8 Combining *ppp* Object and *owin* Object**

In this last step of geospatial data wrangling, I will **mask all ppp object with the owin object** I created earlier to put in place all conflict events within the boundary of Myanmar. Doing so can also optimise the memory usage for large datasets.

::: panel-tabset
**Combine ppp and owin object**

```{r}
# Initialize an empty list to store masked ppp objects
masked_ppp_list <- list()

# Iterate over each ppp object in the list
for (quarter in names(ppp_list)) {
  ppp_obj <- ppp_list[[quarter]]
  # Mask the ppp object with the owin object
  masked_ppp <- ppp_obj[myanmar_owin]
  # Store the masked ppp object in the new list
  masked_ppp_list[[quarter]] <- masked_ppp
}
```

**Check results of (E.g. 2024 Q2)**

```{r}
# Inspect 2024 Q2 masked ppp object
summary(masked_ppp_list$`2024 Q2`)
```
:::

The **`ppp`** object outputted from combining both the point and polygon feature results in the boundary of Myanmar outlining the plot of conflict events as shown.

```{r}
# Set up plotting layout
n <- length(masked_ppp_list)

# Plot each masked ppp object
par(mfrow = c(2,3), mar = c(0,0,1,0))  # Adjust margins as needed
for (quarter in names(masked_ppp_list)) {
  plot(masked_ppp_list[[quarter]], main = paste("Year Quarter:", quarter))
}
```

```{r}
masked_ppp_list_km = list()

for (quarter in names(masked_ppp_list)) {
  ppp_obj <- masked_ppp_list[[quarter]]
  ppp_obj_km <- rescale(ppp_obj, 1000, "km")
  masked_ppp_list_km[[quarter]] <- ppp_obj_km
}
```

## 7. 1st Order Spatio-Temporal Point Pattern Analysis

```{r}
#| code-fold: true
#| code-summary: Set up DayofYear variable per quarter
#| eval: false
Q2_2024 <- conflict_data_sf %>%
  filter(year_quarter == "2024 Q2") %>%
  mutate(DayofYear = yday(event_date))

Q1_2024 <- conflict_data_sf %>%
  filter(year_quarter == "2024 Q1") %>%
  mutate(DayofYear = yday(event_date))

Q4_2023 <- conflict_data_sf %>%
  filter(year_quarter == "2023 Q4") %>%
  mutate(DayofYear = yday(event_date))

Q3_2023 <- conflict_data_sf %>%
  filter(year_quarter == "2023 Q3") %>%
  mutate(DayofYear = yday(event_date))

Q2_2023 <- conflict_data_sf %>%
  filter(year_quarter == "2023 Q2") %>%
  mutate(DayofYear = yday(event_date))

Q1_2023 <- conflict_data_sf %>%
  filter(year_quarter == "2023 Q1") %>%
  mutate(DayofYear = yday(event_date))

Q4_2022 <- conflict_data_sf %>%
  filter(year_quarter == "2022 Q4") %>%
  mutate(DayofYear = yday(event_date))

Q3_2022 <- conflict_data_sf %>%
  filter(year_quarter == "2022 Q3") %>%
  mutate(DayofYear = yday(event_date))

Q2_2022 <- conflict_data_sf %>%
  filter(year_quarter == "2022 Q2") %>%
  mutate(DayofYear = yday(event_date))

Q1_2022 <- conflict_data_sf %>%
  filter(year_quarter == "2022 Q1") %>%
  mutate(DayofYear = yday(event_date))

Q4_2021 <- conflict_data_sf %>%
  filter(year_quarter == "2021 Q4") %>%
  mutate(DayofYear = yday(event_date))

Q3_2021 <- conflict_data_sf %>%
  filter(year_quarter == "2021 Q3") %>%
  mutate(DayofYear = yday(event_date))

Q2_2021 <- conflict_data_sf %>%
  filter(year_quarter == "2021 Q2") %>%
  mutate(DayofYear = yday(event_date))

Q1_2021 <- conflict_data_sf %>%
  filter(year_quarter == "2021 Q1") %>%
  mutate(DayofYear = yday(event_date))
```

### 7.1 **Creating ppp object**

In the code chunk below, **DayofYear** from the **fire_sf** data frame is selected and is included in the output ppp object.

```{r}
#| code-fold: true
#| code-summary: Create ppp object per quarter
#| eval: false
Q2_2024_ppp <- Q2_2024 %>% 
  select(DayofYear) %>%
  as.ppp()

Q1_2024_ppp <- Q1_2024 %>% 
  select(DayofYear) %>%
  as.ppp()

Q4_2023_ppp <- Q4_2023 %>% 
  select(DayofYear) %>%
  as.ppp()

Q3_2023_ppp <- Q3_2023 %>% 
  select(DayofYear) %>%
  as.ppp()

Q2_2023_ppp <- Q2_2023 %>% 
  select(DayofYear) %>%
  as.ppp()

Q1_2023_ppp <- Q1_2023 %>% 
  select(DayofYear) %>%
  as.ppp()

Q4_2022_ppp <- Q4_2022 %>% 
  select(DayofYear) %>%
  as.ppp()

Q3_2022_ppp <- Q3_2022 %>% 
  select(DayofYear) %>%
  as.ppp()

Q2_2022_ppp <- Q2_2022 %>% 
  select(DayofYear) %>%
  as.ppp()

Q1_2022_ppp <- Q1_2022 %>% 
  select(DayofYear) %>%
  as.ppp()

Q4_2021_ppp <- Q4_2021 %>% 
  select(DayofYear) %>%
  as.ppp()

Q3_2021_ppp <- Q3_2021 %>% 
  select(DayofYear) %>%
  as.ppp()

Q2_2021_ppp <- Q2_2021 %>% 
  select(DayofYear) %>%
  as.ppp()

Q1_2021_ppp <- Q1_2021 %>% 
  select(DayofYear) %>%
  as.ppp()
```

### 7.2 Combining ppp with owin object

Next, code chunk below is used to combine the ppp object and the owin object.

```{r}
#| code-fold: true
#| code-summary: Mask the ppp object with owin object
#| eval: false
Q2_2024_owin <- Q2_2024_ppp[myanmar_owin]

Q1_2024_owin <- Q1_2024_ppp[myanmar_owin]

Q4_2023_owin <- Q4_2023_ppp[myanmar_owin]

Q3_2023_owin <- Q3_2023_ppp[myanmar_owin]

Q2_2023_owin <- Q2_2023_ppp[myanmar_owin]

Q1_2023_owin <- Q1_2023_ppp[myanmar_owin]

Q4_2022_owin <- Q4_2022_ppp[myanmar_owin]

Q3_2022_owin <- Q3_2022_ppp[myanmar_owin]

Q2_2022_owin <- Q2_2022_ppp[myanmar_owin]

Q1_2022_owin <- Q1_2022_ppp[myanmar_owin]

Q4_2021_owin <- Q4_2021_ppp[myanmar_owin]

Q3_2021_owin <- Q3_2021_ppp[myanmar_owin]

Q2_2021_owin <- Q2_2021_ppp[myanmar_owin]

Q1_2021_owin <- Q1_2021_ppp[myanmar_owin]
```

Now, I will perform a **spatio-temporal kernel density estimate** on the `owin` object which gives us insights into where and when conflict event occurrences are concentrated within the specified observation window.

```{r}
#| code-fold: true
#| code-summary: Perform spatial temporal KDE per quarter
#| eval: false
Q2_2024_stkde <- spattemp.density(Q2_2024_owin)

Q1_2024_stkde <- spattemp.density(Q1_2024_owin)

Q4_2023_stkde <- spattemp.density(Q4_2023_owin)

Q3_2023_stkde <- spattemp.density(Q3_2023_owin)

Q2_2023_stkde <- spattemp.density(Q2_2023_owin)

Q1_2023_stkde <- spattemp.density(Q1_2023_owin)

Q4_2022_stkde <- spattemp.density(Q4_2022_owin)

Q3_2022_stkde <- spattemp.density(Q3_2022_owin)

Q2_2022_stkde <- spattemp.density(Q2_2022_owin)

Q1_2022_stkde <- spattemp.density(Q1_2022_owin)

Q4_2021_stkde <- spattemp.density(Q4_2021_owin)

Q3_2021_stkde <- spattemp.density(Q3_2021_owin)

Q2_2021_stkde <- spattemp.density(Q2_2021_owin)

Q1_2021_stkde <- spattemp.density(Q1_2021_owin)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2024 Q2
# Load necessary libraries
library(spatstat)
library(magick)
library(viridis)

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2024_Q2_frames")) {
  dir.create("STKDE/2024_Q2_frames")
}

# Get the unique day values
days <- names(Q2_2024_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q2_2024_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2024_Q2_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2024 Q2 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2024_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2024_Q2_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2024 Q1

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2024_Q1_frames")) {
  dir.create("STKDE/2024_Q1_frames")
}

# Get the unique day values
days <- names(Q1_2024_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q1_2024_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2024_Q1_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2024 Q1 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2024_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2024_Q1_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2023 Q4

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2023_Q4_frames")) {
  dir.create("STKDE/2023_Q4_frames")
}

# Get the unique day values
days <- names(Q4_2023_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q4_2023_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2023_Q4_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2023 Q4 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2023_Q4_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2023_Q4_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2023 Q3

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2023_Q3_frames")) {
  dir.create("STKDE/2023_Q3_frames")
}

# Get the unique day values
days <- names(Q3_2023_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q3_2023_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2023_Q3_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2023 Q3 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2023_Q3_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2023_Q3_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2023 Q2

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2023_Q2_frames")) {
  dir.create("STKDE/2023_Q2_frames")
}

# Get the unique day values
days <- names(Q2_2023_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q2_2023_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2023_Q2_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2023 Q2 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2023_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2023_Q2_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2023 Q1

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2023_Q1_frames")) {
  dir.create("STKDE/2023_Q1_frames")
}

# Get the unique day values
days <- names(Q1_2023_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q1_2023_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2023_Q1_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2023 Q1 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2023_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2023_Q1_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2022 Q4

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2022_Q4_frames")) {
  dir.create("STKDE/2022_Q4_frames")
}

# Get the unique day values
days <- names(Q4_2022_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q4_2022_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2022_Q4_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2022 Q4 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2022_Q4_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2022_Q4_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2022 Q3

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2022_Q3_frames")) {
  dir.create("STKDE/2022_Q3_frames")
}

# Get the unique day values
days <- names(Q3_2022_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q3_2022_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2022_Q3_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2022 Q3 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2022_Q3_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2022_Q3_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2022 Q2

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2022_Q2_frames")) {
  dir.create("STKDE/2022_Q2_frames")
}

# Get the unique day values
days <- names(Q2_2022_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q2_2022_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2022_Q2_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2022 Q2 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2022_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2022_Q2_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2022 Q1

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2022_Q1_frames")) {
  dir.create("STKDE/2022_Q1_frames")
}

# Get the unique day values
days <- names(Q1_2022_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q1_2022_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2022_Q1_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2022 Q1 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2022_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2022_Q1_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2021 Q4

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2021_Q4_frames")) {
  dir.create("STKDE/2021_Q4_frames")
}

# Get the unique day values
days <- names(Q4_2021_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q4_2021_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2021_Q4_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2021 Q4 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2021_Q4_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2021_Q4_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2021 Q3

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2021_Q3_frames")) {
  dir.create("STKDE/2021_Q3_frames")
}

# Get the unique day values
days <- names(Q3_2021_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q3_2021_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2021_Q3_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2021 Q3 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2021_Q3_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2021_Q3_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2021 Q2

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2021_Q2_frames")) {
  dir.create("STKDE/2021_Q2_frames")
}

# Get the unique day values
days <- names(Q2_2021_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q2_2021_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2021_Q2_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2021 Q2 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2021_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2021_Q2_stkde.gif"
image_write(animation, path = output_path)
```

```{r}
#| code-fold: true
#| eval: false
#| result: false
#| code-summary: STKDE of 2021 Q1

# Create a directory to store PNG frames
if (!dir.exists("STKDE/2021_Q1_frames")) {
  dir.create("STKDE/2021_Q1_frames")
}

# Get the unique day values
days <- names(Q1_2021_stkde$z)

# Loop through each day and save the plot
for (day in days) {
  kde_result <- Q1_2021_stkde$z[[day]]
  
  # Create PNG filename
  png_filename <- file.path("STKDE/2021_Q1_frames", sprintf("frame_%s.png", day))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(kde_result, main = paste("2022 Q1 - Day", day), col = viridis::viridis(100))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("STKDE/2021_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10)
output_path <- "STKDE/2021_Q1_stkde.gif"
image_write(animation, path = output_path)
```

### 7.3 Plotting STKDE Outputs

Let's plot our animated spatio-temporal KDE outputs for each quarter.

#### 7.3.1 2024 Q1-2 STKDE

```{r}
#| eval: false
library(spatstat)
library(magick)
library(viridis)

# 2024 Q2
frames <- image_read(list.files("STKDE/2024_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2024_Q2_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2024 Q1
frames <- image_read(list.files("STKDE/2024_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2024_Q1_stkde.gif){fig-align="center" width="500"}

::: {.callout-tip title="Observations"}
At the start of **2024 Q1**, we see that the kernel density estimate of Myanmar conflicts tend to **move sporadically** where there are no specific patterns but in **2024 Q2**, we start seeing conflict events occurring more intensely in **Central and Southern Myanmar**.
:::

#### 7.3.2 2023 Q1-Q4 STKDE

```{r}
#| eval: false
# 2023 Q4
frames <- image_read(list.files("STKDE/2023_Q4_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2023_Q4_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2023 Q3
frames <- image_read(list.files("STKDE/2023_Q3_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2023_Q3_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2023 Q2
frames <- image_read(list.files("STKDE/2023_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2023_Q2_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2023 Q1
frames <- image_read(list.files("STKDE/2023_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2023_Q1_stkde.gif){fig-align="center" width="500"}

::: {.callout-tip title="Observations"}
From **2023 Q1 to Q3**, there is a noticeable cluster of conflict events happening in **Central** and **Southern** regions of Myanmar than the other parts of the country. In **2023 Q4**, we can notice more dispersion in conflict events across Myanmar, spreading into **Western** and **Eastern** regions. Throughout 2023, conflict events are **least** **observed** in **North Myanmar.**
:::

#### 7.3.3 2022 Q1-Q4 STKDE

```{r}
#| eval: false
# 2022 Q4
frames <- image_read(list.files("STKDE/2022_Q4_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2022_Q4_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2022 Q3
frames <- image_read(list.files("STKDE/2022_Q3_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2022_Q3_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2022 Q2
frames <- image_read(list.files("STKDE/2022_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2022_Q2_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2022 Q1
frames <- image_read(list.files("STKDE/2022_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2022_Q1_stkde.gif){fig-align="center" width="500"}

::: {.callout-tip title="Observations"}
Similar to 2023, the spread of conflict events in **2022** is largely clustered in **Central** and **Southen parts of Myanmar.** However, we do see some jitters in conflict trends in **2022 Q1** with a **rare sight of conflicts** in the **far North** of Myanmar and **occasional conflicts** in **Southern** Myanmar.
:::

#### 7.3.4 2024 Q1-Q4 STKDE

```{r}
#| eval: false
# 2021 Q4
frames <- image_read(list.files("STKDE/2021_Q4_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2021_Q4_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2021 Q3
frames <- image_read(list.files("STKDE/2021_Q3_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2021_Q3_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2021 Q2
frames <- image_read(list.files("STKDE/2021_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2021_Q2_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2021 Q1
frames <- image_read(list.files("STKDE/2021_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2021_Q1_stkde.gif){fig-align="center" width="500"}

::: {.callout-tip title="Observations"}
Finally, armed conflicts in **2021** is by far the **most random spread** of armed conflicts throughout Myanmar. There is also a high intensity of conflicts in South Myanmar, particularly in the **state of Yangon** while we **rarely** see conflicts occurring in the **extreme** **North** of Myanmar.
:::

## 8. 2nd Order Spatio-Temporal Point Pattern Analysis

Similar to the 2nd order spatial analysis in section 6, I want to explore **spatio-temporal trends** of Myanmar's conflicts and how the events differ in distribution, from **quarter to quarter.** I'll delve into the **four districts** I'm most interested in, that is the districts with the **highest proportions of conflicts** - Yinmarbin, Shwebo, Pakokku and Mandalay.

### 8.1 Using K-Function Estimation

#### 8.1.1 Yinmarbin District

We'll want to compute the **K-Function by quarters** via **`Kest()`** by iterating over each unique quarter in **date format**, then plotting an **animated graph** of the K-Function outputs **per quarter.**

**1) Computing K-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Prepare Dataset for Yinmarbin District
# Set up yinmarbin_ppp_owin_list
conflict_yinmarbin <- conflict_data_sf %>% filter(DT == "Yinmarbin")
unique_quarter <- unique(conflict_yinmarbin$year_quarter)
boundary_yinmarbin <- filter(boundary_sf, DT == "Yinmarbin")
yinmarbin_owin <- as.owin(boundary_yinmarbin)
yinmarbin_ppp_owin_list <- list()

for (quarter in unique_quarter) {
  quarter_data <- conflict_yinmarbin %>% 
    filter(year_quarter == quarter)

  ppp_obj <- as.ppp(quarter_data$geometry)
  ppp_owin_obj <- ppp_obj[yinmarbin_owin]
  ppp_owin_obj_km <- rescale(ppp_owin_obj, 1000, "km")
  yinmarbin_ppp_owin_list[[quarter]] <- ppp_owin_obj_km
}
```

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot K-function for Yinmarbin District
library(magick)

# Create a directory to store PNG frames
path <- file.path("sec_order_k_function", "conflict_yinmarbin")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(yinmarbin_ppp_owin_list)) {
  ppp_owin_obj_km <- yinmarbin_ppp_owin_list[[quarter]]
  K_result <- Kest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_k_function/conflict_yinmarbin", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, . -r ~ r, ylab= "K(d)-r", xlab = "d(km)",
       main = paste("Yinmarbin District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_k_function/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_k_function/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("sec_order_k_function/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](sec_order_k_function/kfunction_yinmarbin.gif)

::: {.callout-tip title="Observations"}
We can observe how the **observed line (K-iso)** is constantly above the **actual line (K-pois)** from **2021 Q2 to 2024 Q2**. This confirms that conflict points in **Yinmarbin** are **highly clustered**. In fact, it is more clustered together than expected by the null hypothesis. There is no K-function outputted for **2021 Q1** as **no conflict points** were observed in Yinmarbin District for that time period.
:::

::: callout-note
**Ripley’s Correction** provides a way to **mitigate the bias** introduced by points near the edge of the study window by accounting for the reduced area for point comparisons near the edges. Hence, this results in a a **more accurate estimate** of the spatial distribution as seen in the **slight difference between actual and expected K-function.**
:::

**2) Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test (i.e. Monta Carlo simulation test) will be conducted. The hypothesis and test are as follows:

-   **Ho** = The distribution of conflict events in Myanmar are randomly distributed.
-   **H1**= The distribution of conflict events in Myanmar are not randomly distributed.
-   The null hypothesis will be rejected if **p-value is smaller** than **alpha value of 0.001**.

By using **`envelop()`**, we can get a more robust interpretation by comparing the observed K-function against a simulation envelope of K-functions generated under the null hypothesis.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Yinmarbin District
library(magick)

# Unique quarters of the year in the dataset
unique_quarter <- unique(conflict_yinmarbin$year_quarter)

# Create a directory to store PNG frames
path <- file.path("k_function_monta_carlo", "conflict_yinmarbin")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(yinmarbin_ppp_owin_list)) {
  ppp_owin_obj_km <- yinmarbin_ppp_owin_list[[quarter]]
  
  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("k_function_monta_carlo/conflict_yinmarbin", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Yinmarbin District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("k_function_monta_carlo/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "k_function_monta_carlo/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("k_function_monta_carlo/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](k_function_monta_carlo/kfunction_yinmarbin.gif)

::: {.callout-tip title="Observations"}
I noticed that the observed line(in solid) has a **somewhat substantial** **deviation** above the **upper** **envelop** (shaded region) generated from the Monte Carlo simulation. This indicates a **strong** **tendancy** for points to be **clustered** in the **Yinmarbin district.** Since this occurs across a wide range of distances, it implies that **clustering is a prominent feature** of the spatial distribution.
:::

#### 8.1.2 Shwebo District

**1) Computing K-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Prepare Dataset for Shwebo District
# Set up shwebo_ppp_owin_list
conflict_shwebo <- conflict_data_sf %>% filter(DT == "Shwebo")
unique_quarter <- unique(conflict_shwebo$year_quarter)
boundary_shwebo <- filter(boundary_sf, DT == "Shwebo")
shwebo_owin <- as.owin(boundary_shwebo)
shwebo_ppp_owin_list <- list()

for (quarter in unique_quarter) {
  quarter_data <- conflict_shwebo %>% 
    filter(year_quarter == quarter)

  ppp_obj <- as.ppp(quarter_data$geometry)
  ppp_owin_obj <- ppp_obj[shwebo_owin]
  ppp_owin_obj_km <- rescale(ppp_owin_obj, 1000, "km")
  shwebo_ppp_owin_list[[quarter]] <- ppp_owin_obj_km
}
```

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot K-function for Shwebo District
library(magick)

# Unique quarters of the year in the dataset
unique_quarter <- unique(conflict_shwebo$year_quarter)

# Create a directory to store PNG frames
path <- file.path("sec_order_k_function", "conflict_shwebo")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(shwebo_ppp_owin_list)) {
  ppp_owin_obj_km <- shwebo_ppp_owin_list[[quarter]]
  
  # Calculate the K-function
  K_result <- Kest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_k_function/conflict_shwebo", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, . -r ~ r, ylab= "K(d)-r", xlab = "d(km)",
       main = paste("Shwebo District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_k_function/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_k_function/kfunction_shwebo.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("sec_order_k_function/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](sec_order_k_function/kfunction_shwebo.gif)

::: {.callout-tip title="Observations"}
For the Shwebo District, the **observed line (K-iso)** also lies constantly above the **actual line (K-pois)** from **2021 Q2 to 2024 Q2**, indicating **clustering** at all distances 'r' of our spatial points. Interestingly, conflict events in **2021 Q1 displayed some tendancy towards a dispersed point pattern** as the observedK-function lies **slightly below** the actual line at a distance of 17km.
:::

**2) Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test (i.e. Monta Carlo simulation test) will be conducted.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Shwebo District
# Create a directory to store PNG frames
path <- file.path("k_function_monta_carlo", "conflict_shwebo")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(shwebo_ppp_owin_list)) {
  ppp_owin_obj_km <- shwebo_ppp_owin_list[[quarter]]

  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("k_function_monta_carlo/conflict_shwebo", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Shwebo District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("k_function_monta_carlo/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "k_function_monta_carlo/kfunction_shwebo.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: true
# Display Plot
frames <- image_read(list.files("k_function_monta_carlo/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](k_function_monta_carlo/kfunction_shwebo.gif)

::: {.callout-tip title="Observations"}
Here, the observed line(in solid) has a **smaller** **deviation** above the **upper** **envelop** generated from the Monte Carlo simulation than in the Yinmarbin data. This indicates a **a somewhat intense level of clustering** in the Shwebo district and in fact, more clustered than would be expected if points were distributed randomly.
:::

#### 8.1.3 Pakokku District

**1) Computing K-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Prepare Dataset for Pakokku District
# Set up pakokku_ppp_owin_list
conflict_pakokku <- conflict_data_sf %>% filter(DT == "Pakokku")
unique_quarter <- unique(conflict_pakokku$year_quarter)
boundary_pakokku <- filter(boundary_sf, DT == "Pakokku")
pakokku_owin <- as.owin(boundary_pakokku)
pakokku_ppp_owin_list <- list()

for (quarter in unique_quarter) {
  quarter_data <- conflict_pakokku %>% 
    filter(year_quarter == quarter)

  ppp_obj <- as.ppp(quarter_data$geometry)
  ppp_owin_obj <- ppp_obj[pakokku_owin]
  ppp_owin_obj_km <- rescale(ppp_owin_obj, 1000, "km")
  pakokku_ppp_owin_list[[quarter]] <- ppp_owin_obj_km
}
```

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot K-function for Pakokku District
library(magick)

# Create a directory to store PNG frames
path <- file.path("sec_order_k_function", "conflict_pakokku")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(pakokku_ppp_owin_list)) {
  ppp_owin_obj_km <- pakokku_ppp_owin_list[[quarter]]
  K_result <- Kest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_k_function/conflict_pakokku", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, . -r ~ r, ylab= "K(d)-r", xlab = "d(km)",
       main = paste("Pakokku District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_k_function/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_k_function/kfunction_pakokku.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("sec_order_k_function/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](sec_order_k_function/kfunction_pakokku.gif)

::: {.callout-tip title="Observations"}
The observed K-function **lies above** the expected K-function outputted from 2021 to 2024**,** indicating **clustering** at all distances 'r' of our spatial points. However, we can observe **milder clustering** from **2021 Q4 to 2024 Q2** as the **magnitude of deviation is significantly smaller** than the period of **2021 Q1 to 2021 Q3.**
:::

**2) Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test (i.e. Monta Carlo simulation test) will be conducted. The hypothesis and test are as follows:

-   **Ho** = The distribution of conflict events in Myanmar are randomly distributed.
-   **H1**= The distribution of conflict events in Myanmar are not randomly distributed.
-   The null hypothesis will be rejected if **p-value is smaller** than **alpha value of 0.001**.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Pakokku District
# Create a directory to store PNG frames
path <- file.path("k_function_monta_carlo", "conflict_pakokku")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(pakokku_ppp_owin_list)) {
  ppp_owin_obj_km <- pakokku_ppp_owin_list[[quarter]]
  
  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("k_function_monta_carlo/conflict_pakokku", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Pakokku District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("k_function_monta_carlo/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "k_function_monta_carlo/kfunction_pakokku.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("k_function_monta_carlo/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](k_function_monta_carlo/kfunction_pakokku.gif)

::: {.callout-tip title="Observations"}
:::

#### 8.1.4 Mandalay District

**1) Computing K-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Prepare Dataset for Mandalay District
# Set up mandalay_ppp_owin_list
conflict_mandalay <- conflict_data_sf %>% filter(DT == "Mandalay")
unique_quarter <- unique(conflict_mandalay$year_quarter)
boundary_mandalay <- filter(boundary_sf, DT == "Mandalay")
mandalay_owin <- as.owin(boundary_mandalay)
mandalay_ppp_owin_list <- list()

for (quarter in unique_quarter) {
  quarter_data <- conflict_mandalay %>% 
    filter(year_quarter == quarter)

  ppp_obj <- as.ppp(quarter_data$geometry)
  ppp_owin_obj <- ppp_obj[mandalay_owin]
  ppp_owin_obj_km <- rescale(ppp_owin_obj, 1000, "km")
  mandalay_ppp_owin_list[[quarter]] <- ppp_owin_obj_km
}
```

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot K-function for Mandalay District
library(magick)
# Create a directory to store PNG frames
path <- file.path("sec_order_k_function", "conflict_mandalay")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(mandalay_ppp_owin_list)) {
  ppp_owin_obj_km <- mandalay_ppp_owin_list[[quarter]]
  
  # Calculate the K-function
  K_result <- Kest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_k_function/conflict_mandalay", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, . -r ~ r, ylab= "K(d)-r", xlab = "d(km)",
       main = paste("Mandalay District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_k_function/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_k_function/kfunction_mandalay.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("sec_order_k_function/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](sec_order_k_function/kfunction_mandalay.gif)

::: {.callout-tip title="Observations"}
:::

**2) Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test (i.e. Monta Carlo simulation test) will be conducted.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Mandalay District
library(magick)
# Create a directory to store PNG frames
path <- file.path("k_function_monta_carlo", "conflict_mandalay")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(mandalay_ppp_owin_list)) {
  ppp_owin_obj_km <- mandalay_ppp_owin_list[[quarter]]

  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("k_function_monta_carlo/conflict_mandalay", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Mandalay District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("k_function_monta_carlo/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "k_function_monta_carlo/kfunction_mandalay.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: true
# Display Plot
frames <- image_read(list.files("k_function_monta_carlo/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](k_function_monta_carlo/kfunction_mandalay.gif)

::: {.callout-tip title="Observations"}
:::

### 8.2 Using L-Function Estimation

#### 8.2.1 Yinmarbin District

**1) Computing L-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot L-function for Yinmarbin District
library(magick)
# Create a directory to store PNG frames
path <- file.path("sec_order_L_function", "conflict_yinmarbin")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(yinmarbin_ppp_owin_list)) {
  ppp_owin_obj_km <- yinmarbin_ppp_owin_list[[quarter]]
  
  # Calculate the L-function
  L_result <- Lest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_L_function/conflict_yinmarbin", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(L_result, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
       main = paste("Yinmarbin District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_L_function/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_L_function/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("sec_order_L_function/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](sec_order_L_function/kfunction_yinmarbin.gif)

::: {.callout-tip title="Observations"}
:::

**2) Performing Complete Spatial Randomness Test**

I will also perform monta carlo simulation test using **`envelope()`** of the **spatstat** package.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Yinmarbin District
library(magick)
# Create a directory to store PNG frames
path <- file.path("L_function_monta_carlo", "conflict_yinmarbin")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(yinmarbin_ppp_owin_list)) {
  ppp_owin_obj_km <- yinmarbin_ppp_owin_list[[quarter]]

  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("L_function_monta_carlo/conflict_yinmarbin", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Yinmarbin District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("L_function_monta_carlo/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "L_function_monta_carlo/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("L_function_monta_carlo/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](L_function_monta_carlo/kfunction_yinmarbin.gif)

::: {.callout-tip title="Observations"}
:::

#### 8.2.2 Shwebo District

**1) Computing L-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot L-function for Shwebo District
library(magick)
# Create a directory to store PNG frames
path <- file.path("sec_order_L_function", "conflict_shwebo")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(shwebo_ppp_owin_list)) {
  ppp_owin_obj_km <- shwebo_ppp_owin_list[[quarter]]
  
  # Calculate the L-function
  L_result <- Lest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_L_function/conflict_shwebo", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(L_result, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
       main = paste("Shwebo District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_L_function/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_L_function/kfunction_shwebo.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("sec_order_L_function/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](sec_order_L_function/kfunction_shwebo.gif)

::: {.callout-tip title="Observations"}
:::

**2) Performing Complete Spatial Randomness Test**

I will also perform monta carlo simulation test using **`envelope()`** of the **spatstat** package.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Shwebo District
library(magick)
# Create a directory to store PNG frames
path <- file.path("L_function_monta_carlo", "conflict_shwebo")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(shwebo_ppp_owin_list)) {
  ppp_owin_obj_km <- shwebo_ppp_owin_list[[quarter]]
  
  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("L_function_monta_carlo/conflict_shwebo", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Shwebo District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("L_function_monta_carlo/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "L_function_monta_carlo/kfunction_shwebo.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("L_function_monta_carlo/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](L_function_monta_carlo/kfunction_shwebo.gif)

::: {.callout-tip title="Observations"}
:::

#### 8.2.3 Pakokku District

**1) Computing L-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot L-function for Pakokku District
# Create a directory to store PNG frames
path <- file.path("sec_order_L_function", "conflict_pakokku")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(pakokku_ppp_owin_list)) {
  ppp_owin_obj_km <- pakokku_ppp_owin_list[[quarter]]
  
  # Calculate the L-function
  L_result <- Lest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_L_function/conflict_pakokku", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(L_result, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
       main = paste("Pakokku District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_L_function/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_L_function/kfunction_pakokku.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("sec_order_L_function/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](sec_order_L_function/kfunction_pakokku.gif)

::: {.callout-tip title="Observations"}
:::

**2) Performing Complete Spatial Randomness Test**

I will also perform monta carlo simulation test using **`envelope()`** of the **spatstat** package.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Pakokku District
# Create a directory to store PNG frames
path <- file.path("L_function_monta_carlo", "conflict_pakokku")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(pakokku_ppp_owin_list)) {
  ppp_owin_obj_km <- pakokku_ppp_owin_list[[quarter]]

  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("L_function_monta_carlo/conflict_pakokku", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Pakokku District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("L_function_monta_carlo/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "L_function_monta_carlo/kfunction_pakokku.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("L_function_monta_carlo/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](L_function_monta_carlo/kfunction_pakokku.gif)

::: {.callout-tip title="Observations"}
:::

#### 8.2.4 Mandalay District

**1) Computing L-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot L-function for Mandalay District
library(magick)
# Create a directory to store PNG frames
path <- file.path("sec_order_L_function", "conflict_mandalay")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(mandalay_ppp_owin_list)) {
  ppp_owin_obj_km <- mandalay_ppp_owin_list[[quarter]]
  
  # Calculate the L-function
  L_result <- Lest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_L_function/conflict_mandalay", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(L_result, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
       main = paste("Mandalay District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_L_function/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_L_function/kfunction_mandalay.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("sec_order_L_function/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](sec_order_L_function/kfunction_mandalay.gif)

::: {.callout-tip title="Observations"}
:::

**2) Performing Complete Spatial Randomness Test**

I will also perform monta carlo simulation test using **`envelope()`** of the **spatstat** package.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Mandalay District
# Create a directory to store PNG frames
path <- file.path("L_function_monta_carlo", "conflict_mandalay")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(mandalay_ppp_owin_list)) {
  ppp_owin_obj_km <- mandalay_ppp_owin_list[[quarter]]
  
  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("L_function_monta_carlo/conflict_mandalay", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Mandalay District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("L_function_monta_carlo/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "L_function_monta_carlo/kfunction_mandalay.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("L_function_monta_carlo/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](L_function_monta_carlo/kfunction_mandalay.gif)

::: {.callout-tip title="Observations"}
:::

## References

Crawley, M. J. (2007). The R Book. Wiley.

The Stata Journal. (2003). Adaptive kernel density estimation. Sage Journals. [https://journals.sagepub.com/doi/pdf/10.1177/1536867X0300300204](https://journals.sagepub.com/doi/pdf/10.1177/1536867X0300300204https://journals.sagepub.com/doi/pdf/10.1177/1536867X0300300204)

```{r}
# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_k_function/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_k_function/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_k_function/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_k_function/kfunction_shwebo.gif"
image_write(animation, path = output_path)

# Read all PNG files from the frames directory
frames <- image_read(list.files("k_function_monta_carlo/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "k_function_monta_carlo/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)

# Read all PNG files from the frames directory
frames <- image_read(list.files("k_function_monta_carlo/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "k_function_monta_carlo/kfunction_shwebo.gif"
image_write(animation, path = output_path)

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_L_function/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_L_function/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_L_function/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_L_function/kfunction_shwebo.gif"
image_write(animation, path = output_path)

# Read all PNG files from the frames directory
frames <- image_read(list.files("L_function_monta_carlo/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "L_function_monta_carlo/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)

# Read all PNG files from the frames directory
frames <- image_read(list.files("L_function_monta_carlo/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "L_function_monta_carlo/kfunction_shwebo.gif"
image_write(animation, path = output_path)
```
