---
title: "Take-home Exercise 1"
subtitle: "Harnessing Geospatial Analytics to Uncover Armed Conflict Patterns in Myanmar"
author: "Foo Jia Yi Samantha"
date-modified: 09/22/2024
date: 09/22/2024
format: 
  html:
    toc-depth: 5
execute: 
  eval: true
  echo: true
  freeze: true
---

## **1. Overview**

### 1.1 Background of Myanmar's Long-Standing Conflicts

![](images/GPA%20Tracker%20(33).png){width="1000"}

The conflict in Myanmar is **not just a result of the coup** but is deeply rooted in the country's decades-old complex ethnic and political landscape, characterised by **tensions between the central government and various ethnic minority groups**, each with its own armed forces. The post-coup violence has exacerbated these **long-standing conflicts,** leading to a severe humanitarian crisis, with thousands killed, hundreds of thousands displaced, and widespread human rights abuses reported.

### 1.2 Objectives of Take-home Exercise 1

As such, Geospatial analytics has become a valuable tool for evaluating and comprehending the intricacies of increasing conflicts. This exercise aims to reveal the spatial and spatio-temporal distribution of armed conflict in Myanmar by leveraging spatial point pattern analysis. Additionally, it aims to gain clearer insights into the geographical and logistical patterns of violence throughout the nation.

By the end of this take-home exercise, I aim to complete these steps in my spatial point pattern analysis in uncovering the distribution of armed conflict in Myanmar.

-   Using appropriate function of **sf** and **tidyverse** packages, import and transform the downloaded armed conflict data and administrative boundary data into sf tibble data.frames.
-   Using the geospatial data sets prepared, derive **quarterly KDE layers.**
-   Using the geospatial data sets prepared, perform **2nd-Order Spatial Point Patterns Analysis.**
-   Using the geospatial data sets prepared, derive **quarterly spatio-temporal KDE layers.**
-   Using the geospatial data sets prepared, perform **2nd-Order Spatio-temporal Point Patterns Analysis.**
-   Using appropriate **tmap** functions, display the KDE and Spatio-temporal KDE layers on **openstreetmap** of Myanmar.
-   Describe the **spatial patterns revealed** by the KDE and Spatio-temporal KDE maps.

### 1.3 About the Datasets

#### 1) **Armed Conflict Data (From ACLED)**

This Armed Conflict Location & Event Data (ACLED) is an independent, impartial, international non-profit organisation which owns an extensive database of violent conflict and protest in countries and territories around the world.

![](images/clipboard-1772056683.png){width="389"}

For the purpose of this exercise, I have downloaded ACLED's data on Myanmar which includes a series of conflict events, particularly between 1 January 2021 to 30 June 2024.

**üîó Source:** [ACLED](https://acleddata.com/)

**üìÅ Format:** comma separated values (CSV)

As the dataset is rather extensive, I will be performing my analysis on armed conflict events in a **quarterly basis** to streamline my tasks. The data included in this dataset are as follows:

+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event Type**                                                                                                                                                                                                                                    |
|                                                                                                                                                                                                                                                   |
| ACLED categorises events into various types. I will mainly be focusing on these four event types: Battles, Explosion/Remote violence, Strategic developments, and Violence against civilians.                                                     |
|                                                                                                                                                                                                                                                   |
| -   **event_id_cnty:** unique ID for each conflict                                                                                                                                                                                                |
| -   **event_type:** category of event e.g.¬†Battle, Violence Against Civilians, Protests, Explosions/Remote Violence, Strategic Developments                                                                                                       |
| -   **sub_event_type:** a more detailed classification within event type                                                                                                                                                                          |
| -   **disorder_type:** classifies the event based on the nature of the disorder e.g.¬†political violence, demonstrations, strategic developments[\[A1\]](https://is415-samanthafoo.netlify.app/take-home_ex/take-home_ex1/take-home_ex1#_msocom_1) |
| -   **civilian_targeting:** yes/no value, whether event involves specifically targeting civilians                                                                                                                                                 |
| -   Note: when ‚Äústrategic developments‚Äù are used in Event Type, it is also used in the disorder type (vice-versa)                                                                                                                                 |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Location and Geospatial Data**                                                                                                                                                                                                                  |
|                                                                                                                                                                                                                                                   |
| The database provides detailed geographic information, pinpointing the exact or approximate locations of conflict events across Myanmar. This includes cities, towns, and rural areas.                                                            |
|                                                                                                                                                                                                                                                   |
| -   **iso:** the country code for Myanmar which uses 104 in this case                                                                                                                                                                             |
| -   **region:** region of conflict within Myanmar                                                                                                                                                                                                 |
| -   **country:** indicates Myanmar                                                                                                                                                                                                                |
| -   **admin1, admin2, admin3:** 1st, 2nd and 3rd level administration division within Myanmar e.g.¬†states, division, sub-division                                                                                                                 |
| -   **location:** specific geographic location or name of the place where the conflict event occurred                                                                                                                                             |
| -   **latitude:** latitude of the conflict event                                                                                                                                                                                                  |
| -   **longitude:** longitude of the conflict event                                                                                                                                                                                                |
| -   **geo_precision:** indicates the level of precision for the geographic coordinates provided                                                                                                                                                   |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Date and Time**                                                                                                                                                                                                                                 |
|                                                                                                                                                                                                                                                   |
| ACLED records the specific dates and, where possible, times of conflict events.                                                                                                                                                                   |
|                                                                                                                                                                                                                                                   |
| -   **event_date:** date of conflict                                                                                                                                                                                                              |
| -   **year:** year of conflict                                                                                                                                                                                                                    |
| -   **time_precision:** accuracy of the date and time information provided                                                                                                                                                                        |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Actors**                                                                                                                                                                                                                                        |
|                                                                                                                                                                                                                                                   |
| -   Indicate the actors involved in the conflict, such as the Tatmadaw (Myanmar‚Äôs military), ethnic armed organizations, local militias, civilian protestors, and other groups.                                                                   |
| -   **actor1:** primary actor involved in the conflict event. E.g. a government force, rebel group, militia, or any organised entity                                                                                                              |
| -   **assoc_actor_1:** a secondary group that is aligned with or supports the primary actor (Actor1) in the event                                                                                                                                 |
| -   **inter1:** an interaction code that categorises actor1, could be a government force, rebel group, military force, rioter, civilian, or other entities                                                                                        |
| -   **interaction:**¬†combined description of actor1 and actor2 (no particular order of aggression)                                                                                                                                                |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Fatalities**                                                                                                                                                                                                                                    |
|                                                                                                                                                                                                                                                   |
| -   **fatalities:**¬†tracks the number of reported fatalities associated with each conflict event                                                                                                                                                  |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Others**                                                                                                                                                                                                                                        |
|                                                                                                                                                                                                                                                   |
| -   **source:** source of information for the conflict event                                                                                                                                                                                      |
| -   **source_scale:** scale of the source e.g.¬†local, national, international                                                                                                                                                                     |
| -   **notes :** additional comments                                                                                                                                                                                                               |
| -   **tags:** keywords associated with the conflict event                                                                                                                                                                                         |
| -   **timestamp:** date and time when conflict event was entered/updated in the database                                                                                                                                                          |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

#### **2) Geospatial Data** (**From Myanmar Information Management Unit)**

I will also be using a geospatial dataset from the Myanmar Information Management Unit (MIMU) in shapefile (.shp) format, specifically of the Myanmar state at the 2^nd^ administrative level with district boundaries.

**üîó Source:** [MIMU](https://geonode.themimu.info/layers/geonode%3Ammr_polbnda_adm2_250k_mimu)

**üìÅ Format:** shapefile (.shp)

My reason for choosing the **district boundary** dataset is that we do not want to select a boundary dataset that is too generalised when analysing conflict events since it **might not provide sufficient insights to trends** where conflict events happen. Neither do we want to analyse a geography that is too detailed (e.g. Admin 3 - townships) since it can be **computationally inefficient** as seen in the types of boundary data below.

![](images/clipboard-679107542.png)

I have donwloaded the two data sets and organised them into my folder as follows.

![](images/clipboard-4213243167.png){width="793"}

## **2. Let‚Äôs Set Up!**

### **2.1 Importing Libraries into R**

To carry out this exercise, I will be using the following R packages:

-   **sf**: a relatively new R package specially designed to import, manage and process vector-based geospatial data in R.
-   **spatstat**: has a wide range of useful functions for point pattern analysis. In this take-home exercise, it will be used to perform 1st- and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer.
-   **raster**: reads, writes, manipulates, analyses and model of gridded spatial data (i.e.¬†raster). In this take-home exercise, it will be used to convert image output generate by spatstat into raster format.
-   **tmap / sparr**: provides functions for plotting cartographic quality static point patterns maps or interactive maps by using leaflet API.
-   **tidyverse / dplyr:** for transforming and organising data for analysis
-   **magick:** used for plotting animated map plots into GIFs for the spatio-temporal point pattern analysis

Now, let‚Äôs install and load these packages in RStudio.

```{r}
pacman::p_load(sf, raster, spatstat, sparr, tmap, tidyverse, magick, dplyr)
```

### **2.2 Importing Data Sets into R**

#### 1) Armed Conflicts Data

Next, I will import the downloaded armed conflict data. For aspatial datasets like this*,* we will import into Rstudio using `read_csv()` function of the **readr** package.

```{r}
# Import armed conflict data
conflict_data <- read_csv("data/aspatial/2021-01-01-2024-06-30-Myanmar.csv")
```

::: {.callout-tip title="Observations"}
The `2021-01-01-2024-06-30-Myanmar.csv` dataset contains 87746 rows and 28 columns which indicates the presence of 87746 unique armed conflict events in Myanmar.
:::

After importing the dataset, we can inspect the dataset using the **`glimpse()`** function.

```{r}
# Inspect the conflict data
glimpse(conflict_data)
```

::: {.callout-tip title="Observations"}
The event_date field shows that it uses a character datatype instead of date - we will fix this later. Also, we can observe that the**`longitude`** and **`langitude`** fields appear to be adopting the **WGS84 geographic** coordinate system since they are in the -180/180 and -90/90 range respectively.
:::

#### 2) Myanmar Boundary Data

::: {.callout-tip title="Observations"}
When working with Myanmar's boundary, we need to assign the appropriate coordinate reference system. However, since Myanmar is split into **two UTM** - West Myanmar (crs: 32646) and East Myanmar (crs: 32647).
:::

Hence, I will also import the administrative boundary data into a simple features tibble data.frame using¬†[*st_read()*](https://r-spatial.github.io/sf/reference/st_read.html)¬†of the **sf** package and **check the number of rows returned for both CRS 32646 and 32647**. This function reads the shapefile data and returns an¬†**`sf`**¬†object that can be used for further analysis.

```{r}
#| code-fold: true
#| code-summary: Find out conflicts count by CRS
conflict_crs <- st_as_sf(conflict_data, coords = c("longitude", "latitude"), crs = 4326) 

# Count number of conflicts for CRS 32646
conflict_data_32646 <- st_transform(conflict_crs, crs = 32646)
count_32646 <- nrow(conflict_data_32646)
# Count number of conflicts for CRS 32647
conflict_data_32647 <- st_transform(conflict_crs, crs = 32647)
count_32647 <- nrow(conflict_data_32647)

crs_counts <- data.frame(
  CRS = c("EPSG: 32646", "EPSG: 32647"),
  Conflicts_Count = c(count_32646, count_32647)
)

print(crs_counts)
```

Since there is no difference in the count, I will decide to focus on **UTM zone 47N (EPSG:32647),** east of Myanmar, for the purpose of this exercise**.** The **`st_transform()`** function below converts the CRS of the **`sf`** object to EPSG:32647.

```{r}
# Import boundary data
boundary_sf <- st_read(dsn = "data/geospatial",layer = "mmr_polbnda_adm2_250k_mimu") %>% st_transform(crs = 32647)
```

In the code below, we can notice that the ESPG code has been updated to **32647**.

```{r}
# Check for changes
st_crs(boundary_sf)
```

Here, I will use the¬†**`plot()`**¬†function which plots the geometry of the¬†**`sf`**¬†object. The¬†**`st_geometry()`**¬†function is used to extract the geometry of the¬†**`mpsz_sf`**¬†object which includes the districts of Myanmar as shown below.

```{r}
par(mar = c(0,0,0,0))
plot(st_geometry(boundary_sf))
```

## 3. Data Wrangling

### 3.1 Fixing Incorrect Datatypes

Recall that the earlier inspection of the `conflict_data` tibble data frame revealed that the datatype indicated for event date is wrongly labelled as a character instead of a date format.

As such, let's convert the datatype to the correct 'date' format as shown below.

```{r}
# Convert the datatype for event_date
conflict_data$event_date <- as.Date(conflict_data$event_date, format = "%d %B %Y")

# Check for changes
head(conflict_data)
```

### 3.2 Adding new year_quarter column

We will want to create a new column to indicate the specific year and quarter for each conflict event since the spatial analysis will be done later in a quarterly manner.

```{r}
#| code-fold: true
#| code-summary: Extract year and quarter
conflict_data$year_quarter <- paste0(
  year(conflict_data$event_date), 
  " Q", 
  quarter(conflict_data$event_date)
)

# View the new data column
unique(conflict_data$year_quarter)
```

### 3.3 Fixing Duplicated Event ID in *conflict_data* Dataframe

As shown, there are presence of duplicates in our dataframe returned by the **`duplicated()`** function.

```{r}
# Check for duplicates
any(duplicated(conflict_data))
```

Based on the duplicated **event ID: MMR64313** for instance. We can observe the two records are of the **same** political violence event happening between **two** **actors** on 30/6/2024, between the People's Defense Force and Military Forces of Myanmar. Upon further research, these two actors are **opposing political parties** of Myanmar's ongoing conflict.

```{r}
# Inspect an instance of the duplciated event IDs
head(conflict_data,2)
```

::: {.callout-tip title="Reflection"}
**Should duplicated data be removed in this analysis?**

A **single event** (e.g. MMR64313) can have duplicated rows **with different actor1 values**, typically due to counterattacks from opposing sides, leading to different data entries into the **`conflict_data`** dataset.

Hence, I will **remove duplicated events** found in the **`conflict_data`** dataframe as long as the rows have the same event ID indicated.
:::

Here, I did another check to ensure there is **not more than 2 possible repeated event IDs** in the first 20 rows of **conflict_data**.

```{r}
#| code-fold: true
#| code-summary: Check duplicated events for first 20 rows
duplicate_counts_first_20 <- conflict_data %>%
  slice(1:20) %>%            
  group_by(event_id_cnty) %>% 
  summarize(count = n()) %>%  
  filter(count > 1)         

# View the result
print(duplicate_counts_first_20)
```

With that checked, I'll remove the duplicated rows with a repeated Event ID but will retain the **actor1** value and append it to a new **actor2** column, assuming two actors are involved in every conflict.

```{r}
#| code-fold: true
#| code-summary: Remove duplicated rows
# Load necessary library
library(dplyr)

# Retrieve data of duplicated rows and summarize actor2, assoc_actor_2, and inter2
merged_duplicates <- conflict_data %>%
  filter(duplicated(event_id_cnty) | duplicated(event_id_cnty, fromLast = TRUE)) %>%
  arrange(event_id_cnty) %>%
  group_by(event_id_cnty) %>%
  summarize(
    actor2 = last(actor1)
  )

# Keep rows without duplicates
conflict_data_no_duplicates <- conflict_data %>%
  filter(!duplicated(event_id_cnty))

# Update conflict_data dataframe with new columns from merged_duplicates
conflict_data <- conflict_data_no_duplicates %>%
  left_join(merged_duplicates, by = "event_id_cnty") %>%
  mutate(
    # Ensure actor2 exists after the join, if not fill with actor1
    actor2 = coalesce(actor2, actor1)
  )

# View dataframe
head(conflict_data[c('event_id_cnty','actor1','actor2')])
```

We can observe that there are no longer any duplicated event IDs in our **`conflict_data`** data frame.

```{r}
any(duplicated(conflict_data))
```

### 3.4 Converting Aspatial Data to Simple Feature Format

For the purpose of this exercise, we will want to integrate and analyse aspatial data in a geographic context. I'll do a check if **`conflict_data`** needs to be converted to a **sf data frame** - if it outputs anything else but `sf`, then it‚Äôs not a simple feature data frame!

```{r}
class(conflict_data)
```

::: {.callout-tip title="Observations"}
We can see that **`conflict_data`** is **not** a sf data frame. Since a non-simple feature data frame does not have a ‚Äúgeometry‚Äù column, we‚Äôll need to convert **`conflict_data`** into a **simple feature** data frame
:::

We can convert **`conflict_data`** into a **simple feature** data frame by using¬†**`st_as_sf()`**¬†from the¬†**sf**¬†package. Addiitionally, we will also need to transform coordinate system from geographic **(ESPG: 4326)** to projected **(ESPG: 32647)** using **`st_transform()`**.

```{r}
# Convert to simple feature format
conflict_data_sf <- st_as_sf(conflict_data, coords = c("longitude", "latitude"), crs=4326) %>% st_transform(crs = 32647)

# Inspect the changes
glimpse(conflict_data_sf)
```

::: {.callout-tip title="Observations"}
Notice that a new column called¬†`geometry`¬†has been added into the data frame. On the other hand, the¬†`longitude`¬†and¬†`latitude`¬†columns have been removed from the data frame.
:::

We can further inspect the newly created 'geometry' column of **`conflict_data_sf`**

```{r}
# Retrieve geometry column
st_geometry(conflict_data_sf)
```

::: {.callout-tip title="Observations"}
It consists of **51,533 features** consisting of **point** **geometric features** where the underlying datum is in WGS 84 format.
:::

To ensure that the coordinate system is correctly updated, we can use the **`st_crs()`** function where we observe that the ESPG code is correctly indicated as **32647**.

```{r}
# Check CRS format
st_crs(conflict_data_sf)
```

### 3.5 Reduce Data File Size

In this section, I will reduce the current Myanmar armed conflict dataset as the time taken for computing the kernel density estimates can take up to 30 minutes long which is not computationally efficient.

#### **1) Remove 'Protests' and 'Riots' Event Types**

I will remove rows in the **`conflicts_data_sf`** dataset that don't focus on the four main event types (Battles, Explosion/Remote violence, Strategic developments, and Violence against civilians), as mentioned in the exercise brief.

```{r}
conflict_data_sf <- conflict_data_sf %>%
  filter(!(event_type %in% c("Protests", "Riots")))

unique(conflict_data_sf$event_type)
```

#### **2) Remove unused columns in boundary_sf**

As seen, there are **8 columns** in the simple feature data frame of **`boundary_sf`**.

```{r}
# Inspect first rows of data in boundary_sf
head(boundary_sf)
```

I will remove **'DT_MMR"** column as we already have the District Name in English in **`DT`** and won't require the district names in Myanmar Language. Next, we will remove the coded versions of **ST (state/region)** and **DT (district)** columns, namely **`ST_PCODE`** and **`DT_PCODE`**. Additionally, we won't need the **`PCode_V`** column since we will be dropping the PCODE column too.

```{r}
boundary_sf <- boundary_sf %>% dplyr::select('OBJECTID', 'ST', 'DT','geometry')
summary(boundary_sf)
```

#### **3) Remove unused columns in conflict_data**

I will also remove unnecessary columns of the **`conflict_data`** data frame that won't be used in our spatial analysis later. I'll rename **admin1** to ST (states) and **admin2** to DT (districts) for easier reference.

```{r}
#| code-fold: true
#| code-summary: Remove unnecessary columns
conflict_data_sf <- conflict_data_sf %>%
  select(event_id_cnty, event_date, year_quarter, disorder_type, 
         event_type, location, admin1, admin2, geometry, actor1, actor2,
         interaction, fatalities) %>%
  rename(
    ST = admin1,
    DT = admin2
  )

summary(conflict_data_sf)
```

### 3.6 Converting Simple Features Data Frame into ppp Object

It is important that we convert **`conflict_data_sf`** (a simple feature data frame) into a **planer point pattern (ppp)** object format, since the **`spatstat`** package that we'll be using for the Spatial Point Pattern Analysis later is specifically designed for working with **ppp-formated** data. Additionally, I will begin with **categorising the ppp objects** into their **unique `year_quarter`** **category**.

```{r}
#| code-fold: true
#| code-summary: Create ppp objects based on year_quarter category
# Create an empty list to store the ppp objects
ppp_list <- list()

# Loop through each unique year_quarter category
for (yq in unique(conflict_data_sf$year_quarter)) {
  # Subset the data for the current year_quarter
  subset_data_sf <- conflict_data_sf %>% filter(year_quarter == yq)
  
  # Convert the subset to a ppp object
  subset_ppp <- as.ppp(subset_data_sf$geometry)
  
  # Add the ppp object to the list
  ppp_list[[yq]] <- subset_ppp
}

# Check list
ppp_list
```

We can visualise the spread of conflict events across each quarter from January 2021 to June 2024 using the **`plot()`** function as shown below.

```{r}
#| code-fold: true
#| code-summary: Visualise the spread of conflicts by year_quarter
#| eval: false
# Ensure 'year_quarter' is a factor
conflict_data_sf$year_quarter <- as.factor(conflict_data_sf$year_quarter)

# Loop through each unique year_quarter and create separate plots
year_quarters <- unique(conflict_data_sf$year_quarter)

# Set up a grid layout for multiple plots (adjust 'mfrow' as needed)
par(mfrow = c(4,4))
par(mar = c(0,0,1,0))

# Loop through each year_quarter and plot
for (yq in year_quarters) {
  subset_data_sf <- conflict_data_sf[conflict_data_sf$year_quarter == yq, ]
  conflict_data_ppp <- as.ppp(subset_data_sf$geometry)
  
  # Plot each subset ppp object
  plot(conflict_data_ppp, main = paste(yq))
}
```

![](images/clipboard-3765192516.png)

::: {.callout-tip title="Observations"}
It is noticeable that there **conflict events have occured more frequently** since 2021 as points plotted on the graph have gotten darker across 2021 to 2024. We can also observe the **possibility of duplicated events** occurring from the darker spots in the plot, in which it appears more intense in Myanmar's central and west regions.
:::

### 3.7 Creating *owin* object

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area, that is Myanmar's boundary in this case. In **`spatstat`**, an object called **`owin`** is specially designed to represent this **polygonal region**.

The code chunk below is used to convert the **`boundary_data_sf`** simple feature data frame into an **`owin`** object of **`spatstat`**.

```{r}
# Convert to owin object
myanmar_owin <- as.owin(boundary_sf)

# Visualise the owin object
plot(myanmar_owin)
```

::: {.callout-tip title="Observations"}
From my observations, the **`as.owin()`** function converts the **`boundary_data_sf`** spatial boundary into a window object that represents the outer boundary of the spatial region and does not handle internal structures or districts we previously saw from the plot of **`boundary_data_sf`**`.`
:::

We can also take a quick look at the **`owin`** object properties as shown. I will be converting it to a data frame for the purposes of getting a quick glimpse of the object.

```{r}
# Summary info of owin object
owin_df <- as.data.frame(myanmar_owin)
print(head(owin_df))
```

### **3.8 Combining ppp Object and owin Object**

In this last step of geospatial data wrangling, I will **mask all ppp object with the owin object** I created earlier to put in place all conflict events within the boundary of Myanmar. Doing so can also optimise the memory usage for large datasets. I'll also make the density values more comprehensible by **re-scaling** the density values from **metres to kilometres** using¬†`rescale()`.

::: panel-tabset
##### **Combine ppp and owin object**

```{r}
# Initialize an empty list to store masked ppp objects
masked_ppp_list_km <- list()

# Iterate over each ppp object in the list
for (quarter in names(ppp_list)) {
  ppp_obj <- ppp_list[[quarter]]
  # Mask the ppp object with the owin object
  masked_ppp <- ppp_obj[myanmar_owin]
  masked_ppp_km <- rescale(masked_ppp, 1000, "km")
  # Store the masked ppp object in the new list
  masked_ppp_list_km[[quarter]] <- masked_ppp_km
}
```

##### **Check results of (E.g. 2024 Q2)**

```{r}
# Inspect 2024 Q2 masked ppp object
summary(masked_ppp_list_km$`2024 Q2`)
```
:::

The¬†**`ppp`**¬†object outputted from combining both the point and polygon feature results in the boundary of Myanmar outlining the plot of conflict events as shown.

```{r}
#| eval: false
# Plot each masked ppp object
par(mfrow = c(2,3), mar = c(0,0,1,0))
for (quarter in names(masked_ppp_list_km)) {
  plot(masked_ppp_list_km[[quarter]], main = paste("Year Quarter:", quarter))
}
```

![](images/clipboard-588971825.png)

![](images/clipboard-2975631520.png)

![](images/clipboard-38708798.png)

**Let's also create combined ppp and owin objects by the districts I am interested in this study.** We'll prepare the objects for the districts: Yinmarbin, Shwebo, Pakokku and Mandalay.

::: panel-tabset
##### Yinmarbin

```{r}
# Prepare Dataset for Yinmarbin District
conflict_yinmarbin = filter(conflict_data_sf, DT == "Yinmarbin")
boundary_yinmarbin <- filter(boundary_sf, DT == "Yinmarbin")

# Create a combined ppp and owin object
yinmarbin_owin <- as.owin(boundary_yinmarbin)
ppp_obj <- as.ppp(conflict_yinmarbin$geometry)

ppp_obj <- as.ppp(st_geometry(conflict_yinmarbin))

# Handle duplicates
ppp_obj <- rjitter(ppp_obj, retry=TRUE, nsim=1, drop=TRUE)

yinmarbin_ppp_owin <- ppp_obj[yinmarbin_owin]
yinmarbin_ppp_owin <- rescale(yinmarbin_ppp_owin, 1000, "km")
```

##### Shwebo

```{r}
# Prepare Dataset for Shwebo District
conflict_shwebo = filter(conflict_data_sf, DT == "Shwebo")
boundary_shwebo <- filter(boundary_sf, DT == "Shwebo")

# Create a combined ppp and owin object
shwebo_owin <- as.owin(boundary_shwebo)
ppp_obj <- as.ppp(conflict_shwebo$geometry)

# Handle duplicates
ppp_obj <- rjitter(ppp_obj, retry=TRUE, nsim=1, drop=TRUE)

shwebo_ppp_owin <- ppp_obj[shwebo_owin]
shwebo_ppp_owin <- rescale(shwebo_ppp_owin, 1000, "km")
```

##### Pakokku

```{r}
# Prepare Dataset for Pakokku District
conflict_pakokku = filter(conflict_data_sf, DT == "Pakokku")
boundary_pakokku <- filter(boundary_sf, DT == "Pakokku")

# Create a combined ppp and owin object
pakokku_owin <- as.owin(boundary_pakokku)
ppp_obj <- as.ppp(conflict_pakokku$geometry)

# Handle duplicates
ppp_obj <- rjitter(ppp_obj, retry=TRUE, nsim=1, drop=TRUE)

pakokku_ppp_owin <- ppp_obj[pakokku_owin]
pakokku_ppp_owin <- rescale(pakokku_ppp_owin, 1000, "km")
```

##### Mandalay

```{r}
# Prepare Dataset for Mandalay District
conflict_mandalay = filter(conflict_data_sf, DT == "Mandalay")
boundary_mandalay <- filter(boundary_sf, DT == "Mandalay")

# Create a combined ppp and owin object
mandalay_owin <- as.owin(boundary_mandalay)
ppp_obj <- as.ppp(conflict_mandalay$geometry)

# Handle duplicates
ppp_obj <- rjitter(ppp_obj, retry=TRUE, nsim=1, drop=TRUE)

mandalay_ppp_owin <- ppp_obj[mandalay_owin]
mandalay_ppp_owin <- rescale(mandalay_ppp_owin, 1000, "km")
```
:::

```{r}
par(mfrow = c(2,2), mar = c(0,0,1,0))
plot(yinmarbin_ppp_owin, main = paste("Yinmarbin District"))
plot(shwebo_ppp_owin, main = paste("Shwebo District"))
plot(pakokku_ppp_owin, main = paste("Pakokku District"))
plot(mandalay_ppp_owin, main = paste("Mandalay District"))
```

::: {.callout-tip title="Observations"}
Here I plot the districts with the highest concentration of armed conflicts. We can observe **localised clustering of armed conflicts** **in certain towns** of each district (darker spots on the map) which also indicates **high frequency of conflicts** occurring in these areas. On the other hand, there are also parts of each district with **smaller frequency of conflicts** but **clusters** **of conflicts formed.**
:::

## 4. Exploratory Data Analysis

### 4.1 Identifying *Districts* with Highest Proportion of Conflicts

It'll also be interesting to find out **specific districts** with the **highest concentration of armed conflicts.** I will first calculate the total occurrences of conflict events per district and add the column to **`boundary_sf`**.

```{r}
#| code-fold: true
#| code-summary: Count number of conflicts by districts
conflict_count <- conflict_data_sf %>%
  group_by(DT) %>%
  summarise(total_count_DT = n()) %>%
  st_drop_geometry() %>%
  select(DT, total_count_DT)

# Perform the join
boundary_sf <- boundary_sf %>%
  left_join(conflict_count, by = "DT")
```

Next, let's calculate the **proportion** of total conflicts and add it as a column into the **`boundary_sf`** dataset as **`proportion_DT`**.

```{r}
# Create new 'proportion_DT' column
boundary_sf <- boundary_sf %>%
  mutate(proportion_DT = total_count_DT / sum(total_count_DT))
head(boundary_sf[c('DT','total_count_DT','proportion_DT')])
```

At a quick glance, we can see that central and southern parts of Myanmar have the highest proportions of armed conflict events occurring.

```{r}
#| code-fold: true
#| code-summary: Set up the points map
#| eval: false
districts_choropleth <-
tm_shape(boundary_sf) +
  tm_fill("proportion_DT",
          n=10,
          title="Proportion",
          style="equal",
          palette="Blues") +
  tm_borders(lwd=0.2,
             alpha=1) +
  tm_text(text = "DT", 
          size = 0.2, 
          col = "black",
          fontface = "bold") +
  tm_layout(main.title = "Distribution of Conflict Points Across Districts",
            legend.outside=FALSE,
            main.title.size=1)
```

```{r}
#| eval: false
# Plot the map
tmap_mode("plot")
tmap_arrange(districts_choropleth)
```

![](images/clipboard-1636605006.png)

More specifically, we can observe that conflict hotspots are mainly found in the districts of **Yinmarbin, Shwebo, Pakokku and Mandalay** which lies in the central regions of Myanmar.

### 4.2 Identifying *States* with Highest Proportion of Conflicts

Instead, let us also explore the **top 10 states** with the highest proportions of armed conflict events.

```{r}
#| code-fold: true
#| code-summary: Count number of conflicts by states
conflict_count <- conflict_data_sf %>%
  group_by(ST) %>%
  summarise(total_count_ST = n()) %>%
  st_drop_geometry() %>%
  select(ST, total_count_ST)

# Perform the join
boundary_sf <- boundary_sf %>%
  left_join(conflict_count, by = "ST")
```

Likewise, I'll add a new column called **`proportion_ST`** to represent the proportion based on each Myanmar state.

```{r}
boundary_sf <- boundary_sf %>%
  mutate(proportion_ST = total_count_ST / sum(total_count_ST))

head(boundary_sf[c('ST','total_count_ST','proportion_ST')])
```

At a quick glance, we can see that **central** and **southern** parts of Myanmar have the highest proportions of armed conflict events occurring, namely in **Sagaing**, **Mandalay,** **Magway** and **Yangon** states as indicated in the map below (darkest shade of blue).

```{r}
#| code-fold: true
#| code-summary: Create the points map
#| eval: false
states_choropleth <-
tm_shape(boundary_sf) +
  tm_fill("proportion_ST",
          n=10,
          title="Proportion",
          style="equal",
          palette="Blues") +
  tm_borders(lwd=0.2,
             alpha=1) +
  tm_text(text = "ST", 
          size = 0.2, 
          col = "black",
          fontface = "bold") +
  tm_layout(main.title = "Distribution of Conflict Points Across States",
            legend.outside=FALSE,
            main.title.size=1)
```

```{r}
#| eval: false
# Plot the map
tmap_mode("plot")
tmap_arrange(states_choropleth)
```

![](images/clipboard-1404098727.png)

### 4.3 Standard Distances of *Top 4 Districts*

Next, I've plot the standard distances for the four districts that I'm most interested in. The codes here will calculate the **average location of the conflict points** within the district (i.e. the mean centre) and measure the **dispersion of points** around the mean centre.

The circle drawn around the mean centre shows us the standard distance to which we can observe that **Mandalay** has the **smallest standard distance** and hence, has the most conflict points closely clustered around the mean centre.

```{r}
#| code-fold: true
#| code-summary: Find hot spot of Yinmarbin District
#| eval: false
# Define the districts
districts <- c("Yinmarbin", "Shwebo", "Pakokku", "Mandalay")

for (district in districts) {
  # Filter the conflict data for the current district
  conflict_district <- filter(conflict_data_sf, DT == district)
  boundary_district <- filter(boundary_sf, DT == district)

  # Create a combined ppp and owin object
  district_owin <- as.owin(boundary_district)
  ppp_obj <- as.ppp(st_geometry(conflict_district))

  # Handle duplicates
  ppp_obj <- rjitter(ppp_obj, retry = TRUE, nsim = 1, drop = TRUE)

  # Mask ppp object with the boundary
  district_ppp_owin <- ppp_obj[district_owin]
  district_ppp_owin <- rescale(district_ppp_owin, 1000, "km")

  # Calculate the mean center
  mean_coords <- c(mean(district_ppp_owin$x), mean(district_ppp_owin$y))

  # Calculate the standard distance
  sd_x <- sd(district_ppp_owin$x)
  sd_y <- sd(district_ppp_owin$y)
  standard_distance <- sqrt(sd_x^2 + sd_y^2)

  # Prepare to plot for the current district
  plot(district_ppp_owin, 
       main = paste("Standard Distance in", district), 
       pch = 19, 
       col = "lightgrey",
       xlim = range(district_ppp_owin$x) + c(-5, 5),  # Expand limits
       ylim = range(district_ppp_owin$y) + c(-5, 5))  # Expand limits

  # Highlight the mean center with an 'X'
  points(mean_coords[1], mean_coords[2], pch = 4, col = "red", cex = 1)  # Smaller 'X'

  # Create a circle around the mean center for the standard distance
  bearing <- seq(0, 2 * pi, length.out = 360)
  circle_x <- mean_coords[1] + standard_distance * cos(bearing)
  circle_y <- mean_coords[2] + standard_distance * sin(bearing)

  # Draw the circle
  lines(circle_x, circle_y, col = 'red', lwd = 2)
}

# Reset the plot layout
par(mfrow = c(1,1), mar = c(0,0,1,0)) 

```

![](images/clipboard-2221996384.png){width="500"}

![](images/clipboard-3242748329.png){width="500"}

![](images/clipboard-333460071.png){width="500"}

![](images/clipboard-2985555552.png){width="500"}

## **5. 1st Order Spatial Point Patterns Analysis**

### 5.1 Kernel Density Estimation

#### 5.1.1 Working with Fixed Bandwidth Methods

Using the geospatial data sets prepared, I will now perform 1st order spatial point pattern analysis by leveraging **kernel density estimation** **(KDE)** to understand the intensity of conflicts in different regions.

I will be using a variety of **fixed** **bandwidth** methods via **`density()`** of the **`spatstat`** package, to determine the most optimal method for this analysis. Namely using **`bw.diggle()`**, **`bw.ppl()`, `bw.CvL()`** and **`bw.scott()`.**

> **Steps taken to calculate the KDE:**
>
> 1.  Extract the masked ppp object for the current quarter.
> 2.  Compute the kernel density estimate by setting the **`signma`** parameters.
> 3.  Plot the kernel density estimate using **`plot()`** where "Bw" represents the optimal bandwidth

For the purposes of identifying the most optimal bandwidth method, I will create a **`ppp_obj`** using the **2021 Q1** conflict events first to assist my decision-making.

```{r}
# Set Up
ppp_obj = masked_ppp_list_km$`2021 Q1`
colours <- colorRampPalette(c("midnightblue", "skyblue"))(100)
```

::: panel-tabset
##### bw.diggle()

The **`bw.diggle()`** bandwidth is referred to as **Diggle's cross-validation bandwidth** which minimises the mean-squared error (MSE) to balance between under and over-smoothing.

```{r}
#| eval: false
# bw.diggle()
kde_conflict_bw_diggle <- density(ppp_obj,
                           sigma=bw.diggle,
                           edge=TRUE,
                           kernel="gaussian")
optimal_bw_d = floor(bw.diggle(ppp_obj)[[1]]*10)/10
plot(kde_conflict_bw_diggle, main = paste("BW: diggle", "(",optimal_bw_d,"km)"), col = colours)
```

![](images/clipboard-115671000.png){width="700"}

##### bw.ppl()

The second bandwidth method I attempted using is **`bw.ppl()`**, This method chooses the bandwidth that minimises the **likelihood cross-validation score** and improving the **prediction accuracy** of the kernel density estimate.

```{r}
#| eval: false
# bw.ppl()
kde_conflict_bw_ppl <- density(ppp_obj,
                           sigma=bw.ppl,
                           edge=TRUE,
                           kernel="gaussian")
optimal_bw_p = floor(bw.ppl(ppp_obj)[[1]]*10)/10
plot(kde_conflict_bw_ppl, main = paste("Bw: ppl", "(",optimal_bw_p,"km)"), col = colours)
```

![](images/clipboard-2342271532.png){width="700"}

##### bw.CvL()

Thirdly, let's explore the bandwidth method **`bw.CvL()`**, also known as **Cronie and Van Lieshout cross-validation,** designed to provide an optimal, adaptive bandwidth for inhomogeneous point patterns.**.** Similar to **`bw.ppl()`**, it aims to **reduce the error measure** but also aims to **balance over and under-fitting** based on the spatial structure of the data.

```{r}
#| eval: false
# bw.CvL()
kde_conflict_bw_CvL <- density(ppp_obj,
                           sigma=bw.CvL,
                           edge=TRUE,
                           kernel="gaussian")
optimal_bw_c = floor(bw.CvL(ppp_obj)[[1]]*10)/10
plot(kde_conflict_bw_CvL, main = paste("Bw: CvL (",optimal_bw_c,"km)"), col = colours)
```

![](images/clipboard-3155458182.png){width="700"}

##### bw.scott()

Lastly, I will explore the `bw.scott()` bandwidth method. This method returns separate bandwidths for the x- and y-axes which is ideal for our spatial data that contains both x and y components. I will combine these bandwidths into a single value for isotropic kernel density estimation by taking the **taking the geometric mean** as shown in the value returned by **`sigma_combined`**.

```{r}
#| eval: false
# bw.scott()
bw_values <- bw.scott(ppp_obj)
sigma_x <- bw_values[1]
sigma_y <- bw_values[2]
sigma_combined <- sqrt(sigma_x * sigma_y)

kde_conflict_bw_scott <- density(ppp_obj,
                           sigma = sigma_combined,
                           edge = TRUE,
                           kernel = "gaussian")

optimal_bw_s = floor(sigma_combined*10)/10
plot(kde_conflict_bw_scott, main = paste("Bw: scott", "(",optimal_bw_s,"km)"), col = colours)
```

![](images/clipboard-3140866975.png){width="700"}
:::

##### **Selecting a Bandwidth Method**

Pramanik N. (2019) proposes that choosing an optimal bandwidth method is crucial in fitting the data appropriately to balance between bias and variance. As such, the four methods listed below cater to different types of data depending on how varied the densities are spread across and the granularity of conflict events. Let's explore which bandwidth method is optimal for our dataset.

-   **`bw.diggle():`** appears to be effective for homogeneous data in seeing **general** conflict hotspots and uses the **smallest bandwidth size**
-   **`bw.ppl()`**: tends to choose **slightly larger bandwidths**, it provide more **localised density estimates** which highlights finer spatial details. As such, we can see **more variability** and **finer** **details** in the density distribution, with more variation between high- and low-density areas.
-   **`bw.CvL()`**: the kernel density plot shows that CvL makes a good attempt in **balancing between detail and smoothness**, making it more suitable for capturing the **overall density trends** in spatial data with some **local structures** highlighted.
-   **`bw.scott():`** as shown, the **geometric mean** ensures equal smoothing in both x and y directions, and is largely similar to **`bw.Cvl()`**, making it a good choice for a **balanced** and **general and fast overview** of the spatial data distribution.

```{r}
#| code-fold: true
#| code-summary: Plot all bandwidth methods
#| eval: false
par(mfrow = c(2,2), mar = c(0,0,1,0)) 
plot(kde_conflict_bw_diggle, main = paste("diggle (",optimal_bw_d,"km)"), col = colours)
plot(kde_conflict_bw_ppl, main = paste("ppl (",optimal_bw_p,"km)"), col = colours)
plot(kde_conflict_bw_CvL, main = paste("CvL (",optimal_bw_c,"km)"), col = colours)
plot(kde_conflict_bw_scott, main = paste("scott (",optimal_bw_s,"km)"), col = colours)
```

![](images/clipboard-3307628259.png)

```{r}
#| eval: false
# Plot histogram to compare KDE
par(mar = c(2,2,2,2),mfrow = c(2,2))
hist(kde_conflict_bw_diggle, main = "diggle")
hist(kde_conflict_bw_ppl, main = "ppl")
hist(kde_conflict_bw_CvL, main = "scott")
hist(kde_conflict_bw_scott, main = "CvL")
```

![](images/clipboard-1721040120.png)

> üí° **Decision: I decided to use** `bw.CvL()` **for computing the KDE** of the masked ppp objects based on each quarter. The KDE function outputs a relatively smooth density estimate that isn't too detailed like **`bw.ppl()`** and not as generalised as **`bw.scott()`**.
>
> This coincides with wider range of spatial concentrations captured by the histogram, doing a good job with both capturing the **non-homogeneous data** spread of our Myanmar conflict data. Moreover, it isn't as computationally heavy as **`bw.ppl()`**.

##### **Putting Together our Fixed KDE using bw.CvL()**

Now, let us perform the KDE computation for the conflict events across all quarters using **`bw.CvL()`**.

```{r}
#| eval: false
# Calculate density using bw.CvL()
par(mfrow = c(2,3), mar = c(0,0,1,0)) 
for (quarter in names(masked_ppp_list_km)) {
  ppp_obj = masked_ppp_list_km[[quarter]]
  kde_conflict_bw <- density(ppp_obj,
                             sigma=bw.CvL,
                             edge=TRUE,
                             kernel="gaussian")
  optimal_bw = floor(bw.CvL(ppp_obj)[[1]]*10)/10
  plot(kde_conflict_bw, main = paste(quarter, "(Bw:",optimal_bw,"m)"), col = colours)
}
```

![](images/clipboard-2221400801.png){width="700"}

![](images/clipboard-2997382061.png){width="700"}

![](images/clipboard-435777924.png){width="700"}

::: {.callout-tip title="Observations"}
**Bandwidth Size**: A bandwidth of around **60,000 to 100,000** is considered relatively large as compared to the bandwidth returned from using **`bw.diggle()`** and **`bw.ppl()`**. Hence, this results in a **smoother density estimate** with less emphasis on local clusters as indicated in the generalised spatial trends.

**Note**: Using a **fixed KDE** is beneficial for our quarterly analysis but the bandwidth returned is different for each quarter. Later on, I'll take the **average bandwidth across different time periods** so we can focus on spatial distribution over time.
:::

#### 5.1.2 Working with Different Kernel Methods

![](images/clipboard-1677584429.png){fig-align="center" width="400"}

Bias is an inevitable issue when it comes to choosing the type of kernel function. Rajagopalan B., et al (1997) states that kernels such as Epanechnikov, Quartic and Disc suffer a **"leakage problem"** where some of the probability mass is truncated at the boundary, **leading to boundary bias**. At the same time, the Gaussian kernel has no truncation, but **small "leakage"** beyond data range of the boundary **inadvertantly** **causes bias to exist still**. Shen et al. (2020) further proposes that the **bandwidth is a more of an influential factor** in kernel estimation than the selection of different kernel functions.

Let us evaluate if this is true by experimenting with a variety of kernel methods as they ultimately control how we weight points within the bandwidth radius. The default kernel in `density.ppp()` is the `gaussian`. alternatives such as `epanechnikov`, `quartic`, and `disc` are also available. I will use the **2021 Q1** conflict data to assist in identifying the most optimal kernel method.

```{r}
#| eval: false
# Set Up
par(mfrow = c(2,2), mar = c(0,0,1,0)) 
ppp_obj = masked_ppp_list_km$`2021 Q1`

# Using the gaussian kernel
kde_conflict_g <- density(ppp_obj,
                           sigma=bw.CvL,
                           edge=TRUE,
                           kernel="gaussian")
plot(kde_conflict_g, main="Gaussian Kernel", col = colours)

# Using the epanechniko kernel
kde_conflict_e <- density(ppp_obj,
                           sigma=bw.CvL,
                           edge=TRUE,
                           kernel="epanechnikov")
plot(kde_conflict_e, main="Epanechnikov Kernel", col = colours)

# Using the quartic kernel
kde_conflict_q <- density(ppp_obj,
                           sigma=bw.CvL,
                           edge=TRUE,
                           kernel="quartic")
plot(kde_conflict_q, main="Quartic Kernel", col = colours)

# Using the disc kernel
kde_conflict_d <- density(ppp_obj,
                           sigma=bw.CvL,
                           edge=TRUE,
                           kernel="disc")
plot(kde_conflict_d, main="Disc Kernel", col = colours)
```

![](images/clipboard-3204700777.png)

```{r}
#| eval: false
# Plot histogram to compare KDE
par(mar = c(2,2,2,2),mfrow = c(2,2))
hist(kde_conflict_g, main = "Gaussian")
hist(kde_conflict_e, main = "Epanechnikov")
hist(kde_conflict_q, main = "Quartic")
hist(kde_conflict_d, main = "Disc")
```

![](images/clipboard-2725383806.png)

::: {.callout-tip title="Observations"}
As expected, we don't see major variations in the smoothness and spread of KDE across a range of distances, and bias continues to be present across all kernel methods as seen from the long-tails. However, there are slight differences in the sharpness of the bandwidth radius in terms of how localised or widespread our data points are being captured.

-   **Gaussian**: provides a **localised** density estimate over the entire spatial extent as compared to **`epanechnikov`** and **`quartic`**. It is good at **highlighting variance** and **opposing ends of conflict intensities** as shown by the wider range used in the legend.
-   **Epanechnikov**: It is more efficient than the **`gaussian`** in terms of variance but produces a slightly rougher surface. It is also more **localised** than the **`quartic`** kernel, focusing on areas near each point, with a sharper boundary at the bandwidth limit.
-   **Quartic**: Results in a **good balance** between smoothness and localised influence, smoother than **`epanechnikov`** but with similar properties. It appears suitable for moderate smoothing and sharper focus on local patterns.
-   **Disc**: results in the **sharpest density estimate** as compared to the other three kernels as all points within a certain distance are made to have equal influence and zero influence beyond that distance.

**Decision:** Hence, I will use the **`quartic`** kernel method to ensure a relatively smooth density estimate with emphasis on local points over distant ones.
:::

##### **5.1.3.1 Using kernel = 'quartic'**

As such, I run the density estimate computation using **`kernel = 'quartic'`**.

```{r}
#| eval: false
# Using 'quartic' kernel
par(mfrow = c(2,3), mar = c(0,0,1,0)) 

for (quarter in names(masked_ppp_list_km)) {
  ppp_obj = masked_ppp_list_km[[quarter]]
  kde_conflict_bw <- density(ppp_obj,
                             sigma=bw.CvL,
                             edge=TRUE,
                             kernel="quartic")
  optimal_bw = floor(bw.CvL(ppp_obj)[[1]]*1000)/1000
  plot(kde_conflict_bw, main = paste(quarter, "(Bw:",optimal_bw,"km)"), col = colours)
}
```

![](images/clipboard-2221400801.png){width="700"}

![](images/clipboard-2997382061.png){width="700"}

![](images/clipboard-4024505047.png){width="700"}

::: {.callout-tip title="Observations"}
We can see **high densities** of armed conflict in the **central** and **southern** regions of Myanmar but more can be uncovered from conflict data. Let's proceed to the next section.
:::

##### **5.1.3.2 Using sigma = 71.831**

For all subsequent fixed KDE computations, I will assign **`sigma`** using the average of the **CvL bandwidth returned** from each quarter**.** Here's the calculations based on the plots returned:

> **Average bandwidth size =** `61.649 + 64.386 + 74.501 + 114.08 + 103.863 + 103.863 + 95.567 + 56.757 + 57.752 + 66.968 + 49.649 + 48.135 + 48.135 + 60.323) / 14 = 71.831`

Let's recompute the Fixed KDE based on the newly calculated average bandwidth such that **sigma = 71.831.** I'll store the quarterly KDE outputs into a list called **`kde_conflict_bw_list`**.

```{r}
# Add KDE into this list
kde_conflict_bw_list <- list()
for (quarter in names(masked_ppp_list_km)) {
  ppp_obj = masked_ppp_list_km[[quarter]]
  kde_conflict_bw <- density(ppp_obj,
                             sigma=71.831,
                             edge=TRUE,
                             kernel="quartic")
  kde_conflict_bw_list[[quarter]] <- kde_conflict_bw
}
```

```{r}
#| eval: false
# Plot graph
par(mfrow = c(2,3), mar = c(0,0,1,0)) 

for (quarter in names(kde_conflict_bw_list)){
  kde_conflict_bw <- kde_conflict_bw_list[quarter]
  plot(kde_conflict_bw, main = paste(quarter, "(Bw: 71.831 km)"), col = colours)
}
```

![](images/clipboard-1310749876.png){width="700"}

![](images/clipboard-2533634750.png){width="700"}

![](images/clipboard-217546280.png){width="700"}

#### 5.1.3 Working with Adaptive KDE

![](images/clipboard-3061655849.png){fig-align="center" width="421"}

As seen above, **fixed** bandwidths tend to **oversmooth** the mode of the distribution. On the contrary, the **adaptive** kernel estimate has the ability to **reduce variability** of estimates in areas with **low density** and **increases** it in areas with **higher density** (The Stata Journal, 2003).

Once again, let us use the **2021 Q1** conflict data to illustrate the difference in outputs of all three adaptive methods.

::: panel-tabset
##### **Voronoi Adaptive KDE**

```{r}
#| eval: false
#| warning: false
# Set Up
ppp_obj = masked_ppp_list_km$`2021 Q1`

# Using Voronoi adaptive KDE
vd_adaptive_kde <- adaptive.density(ppp_obj, f=1, method="voronoi")

# Plot
par(mar = c(0,1,1,1))
plot(vd_adaptive_kde, main = "Voronoi-Dirichlet Adaptive KDE", col = colours)
```

![](images/clipboard-1548554195.png){width="500"}

##### **Adaptive KDE**

```{r}
#| eval: false
# Using adaptive KDE
adaptive_kde <- adaptive.density(ppp_obj, method="kernel")

# Plot
par(mar = c(0,1,1,1))
plot(adaptive_kde, main = "Adaptive KDE", col = colours)
```

![](images/clipboard-328155812.png){width="500"}

##### **Nearest Neighbour Adaptive KDE**

I've used a relatively larger number of neighbours **(i.e. k = 10)** to provide a smoother, more general density estimate to capture broader trends and may smooth out details.

```{r}
#| eval: false
# Using nearest neighbour adaptive KDE
nn_kde <- nndensity(ppp_obj, k=10)

# Plot
par(mar = c(0,1,1,1))
plot(nn_kde, main = "Nearest Neighbour Adaptive KDE", col = colours)
```

![](images/clipboard-2043867264.png){width="500"}
:::

We can also compare the performance of each method based on the **top 4** **states** with highest proportion of conflicts as highlighted earlier.

::: panel-tabset
##### **Voronoi Adaptive KDE**

```{r}
#| code-fold: true
#| code-summary: Plot for Voronoi Adaptive KDE
#| eval: false
# Set Up
par(mfrow = c(2,2), mar = c(0,0,1,0))

# Sagaing
conflict_sagaing <- conflict_data_sf %>%
  filter(ST == "Sagaing")
boundary_sagaing <- filter(boundary_sf, ST == "Sagaing")
district_boundary <- as.owin(st_as_sfc(boundary_sagaing))
ppp_obj <- as.ppp(st_geometry(conflict_sagaing), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- adaptive.density(ppp_obj, f=1, method="voronoi")
plot(kde, main = paste("Sagaing"), col=colours)

# Mandalay
conflict_mandalay <- conflict_data_sf %>%
  filter(ST == "Mandalay")
boundary_mandalay <- filter(boundary_sf, ST == "Mandalay")
district_boundary <- as.owin(st_as_sfc(boundary_mandalay))
ppp_obj <- as.ppp(st_geometry(conflict_mandalay), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- adaptive.density(ppp_obj, f=1, method="voronoi")
plot(kde, main = paste("Mandalay"), col=colours)

# Magway
conflict_magway <- conflict_data_sf %>%
  filter(ST == "Magway")
boundary_magway <- filter(boundary_sf, ST == "Magway")
district_boundary <- as.owin(st_as_sfc(boundary_magway))
ppp_obj <- as.ppp(st_geometry(conflict_magway), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- adaptive.density(ppp_obj, f=1, method="voronoi")
plot(kde, main = paste("Magway"), col=colours)

# Yangon
conflict_yangon <- conflict_data_sf %>%
  filter(ST == "Yangon")
boundary_yangon <- filter(boundary_sf, ST == "Yangon")
district_boundary <- as.owin(st_as_sfc(boundary_yangon))
ppp_obj <- as.ppp(st_geometry(conflict_yangon), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- adaptive.density(ppp_obj, f=1, method="voronoi")
plot(kde, main = paste("Yangon"), col=colours)
```

![](images/clipboard-3356847122.png)

##### **Adaptive KDE**

```{r}
#| code-fold: true
#| code-summary: Plot for Adaptive KDE
#| eval: false
# Set Up
par(mfrow = c(2,2), mar = c(0,0,1,0))

# Sagaing
district_boundary <- as.owin(st_as_sfc(boundary_sagaing))
ppp_obj <- as.ppp(st_geometry(conflict_sagaing), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- adaptive.density(ppp_obj, method="kernel")
plot(kde, main = paste("Sagaing"), col=colours)

# Mandalay
district_boundary <- as.owin(st_as_sfc(boundary_mandalay))
ppp_obj <- as.ppp(st_geometry(conflict_mandalay), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- adaptive.density(ppp_obj, method="kernel")
plot(kde, main = paste("Mandalay"), col=colours)

# Magway
district_boundary <- as.owin(st_as_sfc(boundary_magway))
ppp_obj <- as.ppp(st_geometry(conflict_magway), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- adaptive.density(ppp_obj, method="kernel")
plot(kde, main = paste("Magway"), col=colours)

# Yangon
district_boundary <- as.owin(st_as_sfc(boundary_yangon))
ppp_obj <- as.ppp(st_geometry(conflict_yangon), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- adaptive.density(ppp_obj, method="kernel")
plot(kde, main = paste("Yangon"), col=colours)
```

![](images/clipboard-931791001.png)

![](images/clipboard-931791001.png)

##### **Nearest Neighbour Adaptive KDE**

```{r}
#| code-fold: true
#| code-summary: Plot for NN Adaptive KDE
#| eval: false
# Set Up
par(mfrow = c(2,2), mar = c(0,0,1,0))

# Sagaing
district_boundary <- as.owin(st_as_sfc(boundary_sagaing))
ppp_obj <- as.ppp(st_geometry(conflict_sagaing), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- nndensity(ppp_obj, k=10)
plot(kde, main = paste("Sagaing"), col=colours)

# Mandalay
district_boundary <- as.owin(st_as_sfc(boundary_mandalay))
ppp_obj <- as.ppp(st_geometry(conflict_mandalay), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- nndensity(ppp_obj, k=10)
plot(kde, main = paste("Mandalay"), col=colours)

# Magway
district_boundary <- as.owin(st_as_sfc(boundary_magway))
ppp_obj <- as.ppp(st_geometry(conflict_magway), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- nndensity(ppp_obj, k=10)
plot(kde, main = paste("Magway"), col=colours)

# Yangon
district_boundary <- as.owin(st_as_sfc(boundary_yangon))
ppp_obj <- as.ppp(st_geometry(conflict_yangon), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")
kde <- nndensity(ppp_obj, k=10)
plot(kde, main = paste("Yangon"), col=colours)
```

![](images/clipboard-2647645436.png)
:::

**Comparing the three Adaptive KDE Types**

From the outputs above, it appears that there is no major differences between the distribution of KDE values returned across the three methods, where there is high concentration of points in a specific area. Hence, we will choose to go with¬†`Adapative Kernel`¬†method.

```{r}
#| eval: false
par(mar = c(2,2,2,2),mfrow = c(3,1))
hist(vd_adaptive_kde,main = "Voronoi-Dirichlet Adaptive")
hist(adaptive_kde,main = "Adaptive Kernel")
hist(nn_kde,main = "Nearest-Neighbour Adaptive")
```

![](images/clipboard-3272856398.png)

**Let's compare the results of my two selected fixed and adaptive KDEs (E.g. Magway District)**

```{r}
#| eval: false
#| message: false
par(mfrow = c(1,2), mar = c(0,0,1,0))
district_boundary <- as.owin(st_as_sfc(boundary_magway))
ppp_obj <- as.ppp(st_geometry(conflict_magway), W = district_boundary)
ppp_obj <- rescale(ppp_obj, 1000, "km")

kde_fixed <- density(ppp_obj, sigma=bw.CvL, edge=TRUE, kernel="quartic")
plot(kde_fixed, main = paste("Fixed KDE (CvL | quartic)"), col = colours)
kde_adaptive <- adaptive.density(ppp_obj, method="kernel")
plot(kde_adaptive, main = paste("Adaptive KDE (Kernel)"), col=colours)
```

![](images/clipboard-263685601.png){width="700"}

> We can observe how **adaptive kernels** provides a **more detailed** picture of conflict spatial distribution but since it's largely localised, conflict spots require more effort in identifying and can be **computationally heavy** for this exercise.
>
> Additionally, **varying bandwidth** makes comparisons across **regions** or **time** **periods** (like quarters) **more difficult** because the scale of smoothing is not constant across space and time.

#### **5.1.4** **Converting Gridded KDE Output into Raster**

Next, we need to convert the KDE output to KDE raster layers before it can be viewed using **`tmap`**.

**Step 1) Converting KDE to Spatial Grid Data Frame**

```{r}
#| eval: false
library(grid)
plot_list <- list()
for (quarter in names(kde_conflict_bw_list)) {
  ppp_obj <- kde_conflict_bw_list[[quarter]]
  gridded_ppp_obj <- as(ppp_obj, "SpatialGridDataFrame")
  plot_list[[quarter]] <- spplot(gridded_ppp_obj, main = paste(quarter), col.regions = colours)
}

library(gridExtra)
plot_list_subset1 <- plot_list[1:6]
plot_list_subset2 <- plot_list[7:12]
plot_list_subset3 <- plot_list[13:14]
grid.newpage()
grid.arrange(grobs = plot_list_subset1, ncol = 3, nrow = 2)
grid.newpage() 
grid.arrange(grobs = plot_list_subset2, ncol = 3, nrow = 2)
grid.newpage()
grid.arrange(grobs = plot_list_subset3, ncol = 3, nrow = 2)
```

![](images/clipboard-2964538096.png){width="700"}

![](images/clipboard-59080481.png){width="700"}

![](images/clipboard-655021994.png){width="700"}

**Step 2) Rasterisation of Grid Outputs & Assigning Projection Systems**

```{r}
gridded_ppp_obj_raster_list <- list()
for (quarter in names(kde_conflict_bw_list)) {
  gridded_ppp_obj = kde_conflict_bw_list[[quarter]]
  gridded_ppp_obj_raster <- raster(gridded_ppp_obj)
  projection(gridded_ppp_obj_raster) <- CRS("+init=EPSG:32647")
  gridded_ppp_obj_raster_list[[quarter]] <- gridded_ppp_obj_raster
}

# Inspect for 2024 Q2
gridded_ppp_obj_raster_list$`2024 Q2`
```

**Step 3) Plot Maps**

```{r}
#| eval: false
tmap_mode("plot")
plots_by_quarter <- list()
for (quarter in names(gridded_ppp_obj_raster_list)){
  gridded_ppp_obj_raster = gridded_ppp_obj_raster_list[[quarter]]
  raster_plot <- tm_shape(gridded_ppp_obj_raster) +
    tm_raster("layer", title="Density", palette="Blues") +
    tm_layout(legend.position = c("left","bottom"),frame=FALSE, main.title = quarter,
            main.title.size=1, main.title.position = "center", legend.text.size = 0.5,legend.title.size = 0.7) 
  plots_by_quarter[[quarter]] <- raster_plot
}

tmap_arrange(plots_by_quarter[1:14], ncol=5, nrow=3)
```

![](images/clipboard-756448525.png)

::: {.callout-tip title="Observations"}
Plotting raster grid versions of KDE outputs uses discrete colour ranges which does a good job in highlighting gradual changes in conflict events across an area. Since 2021 Q2, more conflicts are seen in Southern parts of Myanmar. The density range differs for each quarter but we can see an increase in no. of armed conflicts per kilometre from 2021 Q1 to 2022 Q2, which stagnates in density and increases again in 2023 Q4.
:::

### 5.2 Nearest Neighbour Analysis

Our current analyses does not reveal patterns of clustering or dispersion, to which Michael J. Crawley proposes to employ **Clark-Evans** **test** spatial randomness for its simplicity and applicability for **first-order spatial analysis**, which means checking for overall spatial randomness based on nearest-neighbor distances. (Crawley M. J. , 2007)

![](images/clipboard-1436160892.png){fig-align="center" width="386"}

**Clark-Evans Test**

The test checks whether the observed point pattern of armed conflicts in Myanmar shows **clustering** (points are closer than expected under randomness), **dispersion** (points are more spread out), or **randomness**.

#### 5.2.1 Clark-Evans Test (Myanmar)

**The test hypotheses are:**

-   **Ho** = The distribution of armed conflicts in Myanmar are randomly distributed.
-   **H1**= The distribution of armed conflicts in Myanmar are not randomly distributed.
-   The **95%** confident interval will be used.

We will conduct the test using [clarkevans.test()](https://www.rdocumentation.org/packages/spatstat/versions/1.63-3/topics/clarkevans.test) of **statspat**.

```{r}
for (quarter in names(masked_ppp_list_km)) {
  ppp_obj = masked_ppp_list_km[[quarter]]
  print(quarter)
  print(clarkevans.test(ppp_obj,
                  correction="none",
                  clipregion="boundary_sf",
                  alternative=c("clustered"),
                  nsim=99))
}
```

::: {.callout-tip title="Observations"}
For a 95% confidence level, If the **p-value \< 0.05**, I will **reject** **the null hypothesis** of complete spatial randomness and **check if data is uniform (R \> 1)** or **clustered (R \< 1).**

With that said, all tests conducted across each quarter **rejects the null hypothesis** as **p \< 0.05** and spatial points are found to be **clustered** since **R \< 1**.
:::

#### 5.2.2 Clark-Evans Test (Top 4 Districts)

```{r}
#| warning: false
# Yinmarbin District
clarkevans.test(yinmarbin_ppp_owin,
                  correction="none",
                  clipregion="boundary_yinmarbin",
                  alternative=c("clustered"),
                  nsim=39)

# Shwebo District
clarkevans.test(shwebo_ppp_owin,
                  correction="none",
                  clipregion="boundary_shwebo",
                  alternative=c("clustered"),
                  nsim=39)

# Pakokku District
clarkevans.test(pakokku_ppp_owin,
                  correction="none",
                  clipregion="boundary_pakokku",
                  alternative=c("clustered"),
                  nsim=39)

# Mandalay District
clarkevans.test(mandalay_ppp_owin,
                  correction="none",
                  clipregion="boundary_mandalay",
                  alternative=c("clustered"),
                  nsim=39)
```

::: {.callout-tip title="Observations"}
I will **reject the null hypothesis** of complete spatial randomness since the **p values** of each district is **smaller than 0.05**. Additionally, we can observe **clustering of spatial points** since **R \< 1** is returned for all districts. However, this test isn't sufficient in highlighting the statistical significance of the spatial patterns - I'll use the Monte Carlo Simulation later to handle this.
:::

### 5.3 Further Data Exploration

By using the fixed KDE with **CvL bandwidth** and **quartic** **kernel**, let's see what insights can we glean from the density of conflicts in Myanmar.

#### 5.3.1 KDE by *Event Type*

First, let's identify the unique event types in this dataset.

```{r}
# Check unique events
unique(conflict_data_sf$event_type)
```

Now, let us analyse the kernel density estimate of each unique event type found in **`conflict_data_sf`** to identify hot and cold spots across Myanmar.

```{r}
#| code-fold: true
#| code-summary: Plot the KDE based on Event Type
#| eval: false
# Set Up
par(mfrow = c(2,2), mar = c(0,0,1,0)) 

conflict_data_sf %>%
  group_by(event_type) %>%
  group_split() -> conflict_by_event_type

# Convert the sf object to owin
district_boundary <- as.owin(st_as_sfc(boundary_sf))

kde_list <- lapply(seq_along(conflict_by_event_type), function(i) {
  data <- conflict_by_event_type[[i]]
  event_type <- unique(data$event_type)
  ppp_obj <- as.ppp(st_geometry(data), W = district_boundary)
  ppp_obj <- rescale(ppp_obj, 1000, "km")
  kde <- density(ppp_obj,
                 sigma=71.831,
                 edge=TRUE,
                 kernel="quartic")
  plot(kde, main = paste(event_type), col=colours)
  return(kde)
})
```

![](images/clipboard-80379057.png)

::: {.callout-tip title="Observations"}
We can almost see an equal spread of all four event types, with **explosions and strategic violence** being more dominantly found in **Central**-**Western Myanmar**, in the Sagaing and Mandalay states, followed by battles and violence against citizens. All events seem to plaque the **Southern states** (e.g. Yangon) with the exception of battles.
:::

#### 5.3.2 KDE Across Top 4 States With Most Conflicts

Previously, we identified the **top 4** **states** with the highest proportions of conflicts as Sagaing, Mandalay, Magway and Yangon. We can delve deeper into each state by **analysing the intensity of conflicts** across these states using **`density()`**.

```{r}
#| code-fold: true
#| code-summary: Plot the KDE of Top 4 States
#| eval: false
# Set Up
par(mfrow = c(2,2), mar = c(0,0,1,0))

# Sagaing
district_boundary <- as.owin(st_as_sfc(boundary_sagaing))
ppp_obj <- as.ppp(st_geometry(conflict_sagaing), W = district_boundary)
ppp_obj_sagaing <- rescale(ppp_obj, 1000, "km")
kde <- density(ppp_obj_sagaing,
               sigma=71.831,
               edge=TRUE,
               kernel="quartic")
plot(kde, main = paste("Sagaing"), col=colours)

# Mandalay
district_boundary <- as.owin(st_as_sfc(boundary_mandalay))
ppp_obj <- as.ppp(st_geometry(conflict_mandalay), W = district_boundary)
ppp_obj_mandalay <- rescale(ppp_obj, 1000, "km")
kde <- density(ppp_obj_mandalay,
               sigma=71.831,
               edge=TRUE,
               kernel="quartic")
plot(kde, main = paste("Mandalay"), col=colours)

# Magway
district_boundary <- as.owin(st_as_sfc(boundary_magway))
ppp_obj <- as.ppp(st_geometry(conflict_magway), W = district_boundary)
ppp_obj_magway <- rescale(ppp_obj, 1000, "km")
kde <- density(ppp_obj_magway,
               sigma=71.831,
               edge=TRUE,
               kernel="quartic")
plot(kde, main = paste("Magway"), col=colours)

# Yangon
district_boundary <- as.owin(st_as_sfc(boundary_yangon))
ppp_obj <- as.ppp(st_geometry(conflict_yangon), W = district_boundary)
ppp_obj_yangon <- rescale(ppp_obj, 1000, "km")
kde <- density(ppp_obj_yangon,
               sigma=71.831,
               edge=TRUE,
               kernel="quartic")
plot(kde, main = paste("Yangon"), col=colours)
```

![](images/clipboard-2885991334.png)

::: {.callout-tip title="Observations"}
It's interesting that armed conflict isn't evenly distributed across the states though it does seem that **armed conflict** has **inflicted the entire state of Yangon.** Nonetheless, it is worth noting that Yangon is **relatively smaller in size** than the other three states and that will **increase** the density of conflict **quite significantly.**
:::

#### 5.3.3 KDE of Top 4 States by *Event Type*

It'll also be interesting to breakdown each top 4 state **by the event type** category as shown.

::: panel-tabset
##### Sagaing

```{r}
#| code-fold: true
#| code-summary: Plot the KDE for Sagaing by Event Type
#| eval: false
# Set Up
par(mfrow = c(2,2), mar = c(0,0,1,0)) 

conflict_sagaing %>%
  group_by(event_type) %>%
  group_split() -> conflict_by_event_type

# Convert the sf object to owin
district_boundary <- as.owin(st_as_sfc(boundary_sagaing))

kde_list <- lapply(seq_along(conflict_by_event_type), function(i) {
  data <- conflict_by_event_type[[i]]
  event_type <- unique(data$event_type)
  ppp_obj <- as.ppp(st_geometry(data), W = district_boundary)
  ppp_obj <- rescale(ppp_obj, 1000, "km")
  kde <- density(ppp_obj,
                 sigma=71.831,
                 edge=TRUE,
                 kernel="quartic")
  plot(kde, main = paste("Sagaing - ",event_type), col=colours)
  contour(kde, add=TRUE)
  return(kde)
})
```

![](images/clipboard-6085056.png)

##### Mandalay

```{r}
#| code-fold: true
#| code-summary: Plot the KDE for Mandalay by Event Type
#| eval: false
# Set Up
par(mfrow = c(2,2), mar = c(0,0,1,0)) 

conflict_mandalay %>%
  group_by(event_type) %>%
  group_split() -> conflict_by_event_type

# Convert the sf object to owin
district_boundary <- as.owin(st_as_sfc(boundary_mandalay))

kde_list <- lapply(seq_along(conflict_by_event_type), function(i) {
  data <- conflict_by_event_type[[i]]
  event_type <- unique(data$event_type)
  ppp_obj <- as.ppp(st_geometry(data), W = district_boundary)
  ppp_obj <- rescale(ppp_obj, 1000, "km")
  kde <- density(ppp_obj,
                 sigma=71.831,
                 edge=TRUE,
                 kernel="quartic")
  plot(kde, main = paste("Mandalay - ",event_type), col=colours)
  contour(kde, add=TRUE)
  return(kde)
})
```

![](images/clipboard-3881088639.png)

##### Magway

```{r}
#| code-fold: true
#| code-summary: Plot the KDE for Magway by Event Type
#| eval: false
# Set Up
par(mfrow = c(2,2), mar = c(0,0,1,0)) 

conflict_magway %>%
  group_by(event_type) %>%
  group_split() -> conflict_by_event_type

# Convert the sf object to owin
district_boundary <- as.owin(st_as_sfc(boundary_magway))

kde_list <- lapply(seq_along(conflict_by_event_type), function(i) {
  data <- conflict_by_event_type[[i]]
  event_type <- unique(data$event_type)
  ppp_obj <- as.ppp(st_geometry(data), W = district_boundary)
  ppp_obj <- rescale(ppp_obj, 1000, "km")
  kde <- density(ppp_obj,
                 sigma=71.831,
                 edge=TRUE,
                 kernel="quartic")
  plot(kde, main = paste("Magway - ",event_type), col=colours)
  contour(kde, add=TRUE)
  return(kde)
})
```

![](images/clipboard-2674625985.png)

##### Yangon

```{r}
#| code-fold: true
#| code-summary: Plot the KDE for Yangon by Event Type
#| eval: false
# Set Up
par(mfrow = c(2,2), mar = c(0,0,1,0)) 

conflict_yangon %>%
  group_by(event_type) %>%
  group_split() -> conflict_by_event_type

# Convert the sf object to owin
district_boundary <- as.owin(st_as_sfc(boundary_yangon))

kde_list <- lapply(seq_along(conflict_by_event_type), function(i) {
  data <- conflict_by_event_type[[i]]
  event_type <- unique(data$event_type)
  ppp_obj <- as.ppp(st_geometry(data), W = district_boundary)
  ppp_obj <- rescale(ppp_obj, 1000, "km")
  kde <- density(ppp_obj,
                 sigma=71.831,
                 edge=TRUE,
                 kernel="quartic")
  plot(kde, main = paste("Yangon - ",event_type), col=colours)
  contour(kde, add=TRUE)
  return(kde)
})
```

![](images/clipboard-1632126526.png)
:::

::: {.callout-tip title="Observations"}
The kernel density of **violence against civillians** is generally found to be the **lowest** amongst all conflict events. Additionally, all types of armed conflicts tend to **occur repeatedly** in the **same parts of each state.** E.g. conflicts regarding strategic development tend to happen in Southern part of the Sagaing state, just as it is for explosions/remote violence.
:::

#### 5.5.4 KDE by Interaction Type

```{r}
# Convert Interaction Code to Text
unique(conflict_data_sf$interaction)
```

```{r}
library(dplyr)

# Create a named vector for mapping interaction values
interaction_map <- c(
  "10" = "SOLE STATE FORCES ACTION",
  "11" = "STATE FORCES VERSUS STATE FORCES",
  "12" = "STATE FORCES VERSUS REBELS",
  "13" = "STATE FORCES VERSUS POLITICAL MILITIA",
  "14" = "STATE FORCES VERSUS IDENTITY MILITIA",
  "17" = "STATE FORCES VERSUS CIVILIANS",
  "18" = "STATE FORCES VERSUS EXTERNAL/OTHER FORCES",
  "20" = "SOLE REBEL ACTION",
  "22" = "REBELS VERSUS REBELS",
  "23" = "REBELS VERSUS POLITICAL MILITIA",
  "24" = "REBELS VERSUS IDENTITY MILITIA",
  "27" = "REBELS VERSUS CIVILIANS",
  "28" = "REBELS VERSUS OTHERS",
  "30" = "SOLE POLITICAL MILITIA ACTION",
  "33" = "POLITICAL MILITIA VERSUS POLITICAL MILITIA",
  "34" = "POLITICAL MILITIA VERSUS IDENTITY MILITIA",
  "37" = "POLITICAL MILITIA VERSUS CIVILIANS",
  "38" = "POLITICAL MILITIA VERSUS OTHERS",
  "40" = "SOLE IDENTITY MILITIA ACTION",
  "44" = "IDENTITY MILITIA VERSUS IDENTITY MILITIA",
  "47" = "IDENTITY MILITIA VERSUS CIVILIANS",
  "48" = "IDENTITY MILITIA VERSUS OTHER",
  "70" = "SOLE CIVILIAN ACTION",
  "77" = "CIVILIANS VERSUS CIVILIANS",
  "78" = "OTHER ACTOR VERSUS CIVILIANS",
  "80" = "SOLE OTHER ACTION",
  "88" = "OTHER VERSUS OTHER"
)

conflict_data_sf <- conflict_data_sf %>%
  rename(interaction_code = interaction) %>%
  mutate(interaction = interaction_map[as.character(interaction_code)])  

# View the updated dataframe
head(conflict_data_sf[c("interaction_code","interaction")])
```

##### **1. Involvement of Political** **Militia**

The conflict landscape in Myanmar is complex and fragmented, with political militias focused on **advancing political agendas** or **controlling governance structures**. Let's discover how the density of armed conflicts differ for each interaction of the political militia. They can be associated as either of these groups.

-   **Pro-Government Militias**: supporting the central government or Tatmadaw, such as Pyithu Sit and BGFs.
-   **Pro-Democracy Militias**: emerged as part of the resistance movement against the military junta. E.g. the People's Defence Forces (PDF)

```{r}
#| code-fold: true
#| code-summary: Plot conflicts involving political militia
#| eval: false
codes <- c('13','23','33')
par(mfrow = c(3,1), mar = c(0,0,1,0)) 

for(code in codes) {
  # Filter for the specific interaction type
  filtered_data <- conflict_data_sf %>%
    filter(interaction_code == code)
  
  # Convert to ppp object
  boundary_owin <- as.owin(boundary_sf)
  ppp_owin_obj <- as.ppp(filtered_data$geometry, W = boundary_owin)
  ppp_owin_obj_km <- rescale(ppp_owin_obj, 1000, "km")
  
  # Compute KDE
  kde <- density(ppp_owin_obj_km,
                 sigma=71.831,
                 edge=TRUE,
                 kernel="quartic")
  
  # Plot the KDE
  plot(kde, main = paste(interaction_map[code]), col = colours)
}
```

![](images/clipboard-2276729289.png)

::: {.callout-tip title="Observations"}
The political army or organisations tend to be less involved with unarmed civilians but state forces, rebels and other policial militia.

1.  **Against State Forces**

-   **High density of conflicts** with state forces (e.g. police) in **central** and **western** Myanmar
-   These regions have significant ethnic diversity and political grievances. E.g. **Rakhine State in the west** is home to ethnic Rakhine groups who have historically sought greater autonomy and have been involved in conflicts with state forces.
-   Central regions, such as **Sagaing and Magway,** have also seen intense resistance against state forces, particularly after the 2021 military coup.

2.  **Against Rebels**

-   Rebels and political militias **operate throughout Myanmar** with varying objectives but of a **much smaller intensity** than with other actors (seen from its low density scale).
-   Clashes between rebels and political militias can stem from **differing political goals, territorial disputes, or strategic interests**.
-   For instance, a rebel group might view a political militia as a rival in a contested region or as a competitor for local support.

3.  **Against other Political Miliitia**

-   In **central and western Myanmar,** where political militias are more active, there is often competition among different resistance groups. These militias may have different leadership, ideologies, or goals, leading to clashes.
:::

##### **2. Involvement of Identity Militia**

Identity militias are typically organised around **ethnic, religious, or cultural identities**. heir main goal is to protect the interests, rights, and autonomy of specific identity-based groups within Myanmar.

```{r}
#| code-fold: true
#| code-summary: Plot conflicts involving identity militia
#| eval: false
codes <- c('14','24')
par(mfrow = c(2,1), mar = c(0,0,1,0)) 

for(code in codes) {
  # Filter for the specific interaction type
  filtered_data <- conflict_data_sf %>%
    filter(interaction_code == code)
  
  # Convert to ppp object
  boundary_owin <- as.owin(boundary_sf)
  ppp_owin_obj <- as.ppp(filtered_data$geometry, W = boundary_owin)
  ppp_owin_obj_km <- rescale(ppp_owin_obj, 1000, "km")
  
  # Compute KDE
  kde <- density(ppp_owin_obj_km,
                 sigma=71.831,
                 edge=TRUE,
                 kernel="quartic")
  
  # Plot the KDE
  plot(kde, main = paste(interaction_map[code]), col = colours)
}
```

![](images/clipboard-1772587757.png){fig-align="center" width="650"}

::: {.callout-tip title="Observations"}
Armed conflicts involving the identity militia is of a **much smaller intensity** than political militia with about 5e\^-0.5 or **3 conflict events per kilometre**.

1.  **State Forces vs Identity Militia**

-   Conflicts between these two parties are **concerntrated in the Western region** which has a history of conflict, including uprisings against **colonial and post-colonial governments.**

-   Additionally, the region's **proximity to Bangladesh** has some influence on local conflicts as ethnic groups in Myanmar may have connections or support from across the border.

-   In the **Rakhine State** of western Myanmar, historical grievances and **demands for autonomy** has also fueled tensions between these groups and the central government (Crisis Group, 2024).

2.  **Rebels vs identity militia**

-   **Higher intensity** of armed conflicts are seen in **North** Myanmar
-   Northern Myanmar hosts **various ethnic armed groups and rebel factions** that seek autonomy or independence. (E.g. Kachin, Shan and Chin)
-   Northern Myanmar is **rich** **in natural resources**, e.g. jade and timber. Control over these resources can be a significant driver of conflict, as various armed groups vie for control and when there's a **lack of economic opportunities.** (Fishbein & Lusan, 2022)
-   Unresolved conflicts from **colonial and post-colonial periods** continue to influence current tensions between different ethnic groups and armed factions in the Northen region.
:::

##### **3**. **Involvement of Civilian Actors**

```{r}
#| code-fold: true
#| code-summary: Plot conflicts involving civilians
#| eval: false
codes <- c('17', '27', '37', '47', '78')
par(mfrow = c(3,2), mar = c(0,0,1,0)) 

for(code in codes) {
  # Filter for the specific interaction type
  filtered_data <- conflict_data_sf %>%
    filter(interaction_code == code)
  
  # Convert to ppp object with boundary window
  boundary_owin <- as.owin(boundary_sf)
  ppp_obj <- as.ppp(filtered_data$geometry, W = boundary_owin)
  
  # Rescale the ppp object
  ppp_obj_km <- rescale(ppp_obj, 1000, "km")
  
  # Compute KDE
  kde <- density(ppp_obj_km,
                 sigma = 71.831,
                 edge = TRUE,
                 kernel = "quartic")
  
  # Plot the KDE
  plot(kde, main = paste(interaction_map[code]), col = colours)
}

```

![](images/clipboard-3608045083.png)

::: {.callout-tip title="Observations"}
Across all actors, we see that perhaps civilians are involved with the biggest range of actors.

Notably, we see the **lowest intensity** of clashes with **identity militia** which could stem from how civilians might be part of the **same social/ethnic networks** as the identity militia and these militia may seek the support of civilian populations too.

In contrast, **state forces and civilians** have the highest intensity of armed conflicts

-   In **Western** **Rakhine State,** Buddhist-majority and Muslim-minority communities have experienced significant tension causing state forces to act in response to these tensions which has led to severe clashes with civilian populations.

-   Reports of **human rights abuses,** including arbitrary arrests, torture, and extrajudicial killings by state forces, has led to large-scale displacement and humanitarian crises, **further exacerbating tensions** between state forces and civilians. The **struggle for resources and safety** often intensifies the conflicts. (Farge E. & Mantovani C., 2024)
:::

##### **4**. **Civilians Involvement by Event Type**

```{r}
#| code-fold: true
#| code-summary: Compute KDE of Civilians by Event Type
#| eval: false
# Set Up
par(mfrow = c(2,2), mar = c(0,0,1,0)) 
codes <- c('17', '27', '37', '47', '78')

conflict_data_sf %>%
  filter(interaction_code %in% codes) %>%
  group_by(event_type) %>%
  group_split() -> conflict_by_event_type

# Convert the sf object to owin
district_boundary <- as.owin(st_as_sfc(boundary_sf))

kde_list <- lapply(seq_along(conflict_by_event_type), function(i) {
  data <- conflict_by_event_type[[i]]
  event_type <- unique(data$event_type)
  ppp_obj <- as.ppp(st_geometry(data), W = district_boundary)
  ppp_obj <- rescale(ppp_obj, 1000, "km")
  kde <- density(ppp_obj,
                 sigma=71.831,
                 edge=TRUE,
                 kernel="quartic")
  plot(kde, main = paste(event_type), col=colours)
  return(kde)
})
```

![](images/clipboard-332831084.png){width="662"}

::: {.callout-tip title="Observations"}
Civilians are seen to be embroiled mostly in conflicts resulting from **strategic development** and **violence against civilians events,** primarily in Central and Western Myanmar. Fortunately, conflicts involving **explosions or remote violence is not as intense** against civilians but this raises a great concern on the **humanitarian crisis** faced by civilians in Myanmar.
:::

#### 5.5.5 OpenStreetMap Myanmar - Spatial Points

Using **tmap** functions, I will display an interactive view of te KDE layers on **openstreetmap** of Myanmar to observe intensity of conflicts at the district level. We can see higher intensities of conflict in central districts (e.g. Yinmarbin, Pakokku and Shwebo) and western districts (e.g. Yangon).

```{r}
#| warning: false
ppp_obj<- as.ppp(conflict_data_sf$geometry)
ppp_owin_obj <- ppp_obj[myanmar_owin]
ppp_owin_obj_km <- rescale(ppp_owin_obj, 1000, "km")

kde_fixed <- density(ppp_owin_obj_km, sigma=bw.CvL, edge=TRUE, kernel="quartic")

raster_kde_fixed <- raster(kde_fixed)

projection(raster_kde_fixed) <- CRS("+init=EPSG:32647 +units=km")
```

```{r}
# Plot KDE Map on OpenStreetMap
tmap_mode('view')
kde_fixed_output <- tm_basemap(server = "OpenStreetMap.HOT") +
  tm_basemap(server = "Esri.WorldImagery") +
  tm_shape(raster_kde_fixed) +
  tm_raster("layer",
            n = 10,
            title = "KDE Fixed CvL",
            alpha = 0.6,
            palette = c("#fafac3","#fd953b","#f02a75","#b62385","#021c9e")) +
  tm_shape(boundary_sf)+
  tm_polygons(alpha=0.1,id="DT")+
  tmap_options(check.and.fix = TRUE)

kde_fixed_output
tmap_mode("plot")
```

## 6. 2nd Order Spatial Point Patterns Analysis

Unlike 1st-order analysis, which studies the intensity of points (e.g., density), let's also leverage 2nd-order analysis to examine how points are distributed relative to each other, which can offer deeper insights into the spatial interaction between events.

I will use the K-function and L-function is to understand the spatial relationships between events, particularly focusing on whether the points exhibit clustering, uniformity, or randomness.

### 6.1 Using K-Function Estimation

**K-function** helps detect spatial patterns by comparing the observed distribution of points against a random pattern at different distances.

#### **6.1.1 Yinmarbin District**

**1) Computing K-Function Estimation**

For Yinmarbin district, let's compute K-function estimates by using **`Kest()`** of the **spatstat** package by using the **`yinmarbin_ppp_owin`** masked ppp object we created previously.

```{r}
#| eval: false
K_ck = Kest(yinmarbin_ppp_owin, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(km)",
       main = paste("Yinmarbin District (K-Function)"))
```

![](images/d(km).png){width="700"}

::: {.callout-tip title="Observations"}
**How to interpret the plot:**

-   **K-iso** represents the observed or estimated K-function value calculated from the actual data
-   **K-pois** is the theoretical K-function that represents the expected K-function

**With that said...**

We can observe how the **observed line (K-iso)** is found to lie above the **theoretical line (K-pois)** which suggests conflict points in **Yinmarbin** are **highly clustered**. Clustering is the **strongest** at a **20km distance** which suggests **large-scale clustering**. In fact, it is more clustered together than expected by the null hypothesis.

**Note:** Since I had used the default **`edge = TRUE`** settings, edge correction will account for missing neighbours outside the boundary which helps maintain an accurate estimate of the K-function. Hence, there is **marginal difference** in the actual and expected K-function.
:::

**2) Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test (i.e. Monte Carlo simulation test) will be conducted. The hypothesis and test are as follows:

-   **Ho** = The distribution of conflict events in Myanmar are randomly distributed.
-   **H1**= The distribution of conflict events in Myanmar are not randomly distributed.
-   The null hypothesis will be rejected if the **observed K-function lies above/below** the theoretical K-function and envelope.

By using **`envelope()`**, we can get a more robust interpretation by comparing the observed K-function against a simulation envelope of K-functions generated under the null hypothesis.

::: callout-note
To achieve a **95% confidence envelope** in a K-function test with **Complete Spatial Randomness,** I will need to exclude the upper 2.5% and lower 2.5% of the simulated K-functions., i.e. I will need to generate **at least** **40 simulations** where **`nsim = 39`**.

We'll set **`rank = 1`** for a conservative setting, such that the envelope is based on the **extreme values** (highest and lowest) from the simulations.
:::

```{r}
#| eval: false
# Monte Carlo test with K-function
K_yinmarbin_csr <- envelope(yinmarbin_ppp_owin, Kest, 
                            nsim = 39, rank = 1, glocal=TRUE)
plot(K_yinmarbin_csr, main = paste("Yinmarbin District (CSR)"))
```

![](images/clipboard-4215508963.png){width="700"}

::: {.callout-tip title="Observations"}
The **tight envelope** suggests we can be confident that deviations between the observed and theoretical lines are meaningful, rather than due to random variation. It also indicates that simulations under CSR are producing **homogeneous patterns**.

On the other hand, the **observed** K-function line is **constantly above** the shaded region of the envelope and theoretical line, suggesting that observed spatial pattern **are more clustered than expected** under the null hypothesis of CSR
:::

Just to be sure that there is no improvement in a higher number of simulations, I ran it again with **nsim = 99**. As shown below, the k-function output is similar but with a **somewhat** **smoother** **plot** than before since we are working with less variability. Hence, I'll stick to **nsim = 39.**

![](images/clipboard-2378436398.png){width="700"}

#### **6.1.2 Shwebo District**

**1) Computing K-Function Estimation**

For Shwebo district, let's compute K-function estimates by using **`Kest()`** of the **spatstat** package.

```{r}
#| eval: false
K_ck = Kest(shwebo_ppp_owin, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(km)",
       main = paste("Shwebo District (K-Function)"))
```

The observed line is consistently above at all distances, implying that conflict events are clustered at both small and large areas, rather than being randomly distributed across the area.

![](images/d(km)%20(1).png){width="700"}

::: {.callout-tip title="Observations"}
The observed line is consistently above at all distances, implying that conflict events are clustered at **both small and large areas,** rather than being randomly distributed across the area.
:::

**2) Performing Complete Spatial Randomness Test**

```{r}
#| eval: false
# Monte Carlo test with K-function
K_shwebo_csr <- envelope(shwebo_ppp_owin, Kest, 
                     nsim = 39, rank = 1, glocal=TRUE)
plot(K_shwebo_csr, main = paste("Shwebo District (CSR)"))
```

![](images/clipboard-998335521.png){width="700"}

::: {.callout-tip title="Observations"}
Since the **observed line** lies above the envelope and the shaded region of the envelope is rather narrow, it **strongly suggests clustering in Shwebo**, rather than due to random variation.
:::

#### **6.1.3 Pakokku District**

**1) Computing K-Function Estimation**

For Pakokku district, let's compute K-function estimates by using **`Kest()`** of the **spatstat** package.

```{r}
#| eval: false
K_ck = Kest(pakokku_ppp_owin, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(km)",
       main = paste("Pakokku District (K-Function)"))
```

![](images/clipboard-2832050063.png){width="700"}

::: {.callout-tip title="Observations"}
We can observe how the **observed line (K-iso)** is found to be above the **theoretical line (K-pois)** which suggests conflict points in **Pakokku** are **highly clustered**. In fact, it is more clustered together than expected by the null hypothesis.
:::

**2) Performing Complete Spatial Randomness Test**

```{r}
#| eval: false
# Monte Carlo test with K-function
K_pakokku_csr <- envelope(pakokku_ppp_owin, Kest, 
                     nsim = 39, rank = 1, glocal=TRUE)
plot(K_pakokku_csr, main = paste("Pakokku District (CSR)"))
```

![](images/clipboard-2356387518.png){width="700"}

::: {.callout-tip title="Observations"}
Likewise, we can be certain about the clustering patterns in Pakokku since the observed K values deviates above the envelope as shown.
:::

#### **6.1.4 Mandalay District**

**1) Computing K-Function Estimation**

For Mandalay district, let's compute K-function estimates by using **`Kest()`** of the **spatstat** package.

```{r}
#| eval: false
K_ck = Kest(mandalay_ppp_owin, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(km)",
       main = paste("Mandalay District (K-Function)"))
```

![](images/clipboard-363816982.png){width="700"}

::: {.callout-tip title="Observations"}
Significant clustering is observed generally across multiple distances in Mandalay and clusterinng is particularly evident at **longer spatial distances** in Mandalay seen from how the deviations of observed K values increase by the distance.
:::

**2) Performing Complete Spatial Randomness Test**

```{r}
#| eval: false
# Monte Carlo test with K-function
K_mandalay_csr <- envelope(mandalay_ppp_owin, Kest, 
                     nsim = 39, rank = 1, glocal=TRUE)
plot(K_mandalay_csr, main = paste("Mandalay District (CSR)"))
```

![](images/clipboard-2726224351.png){width="700"}

::: {.callout-tip title="Observations"}
The envelope size continues to be narrow with K values plotted above the envelope. This strongly suggests that the point pattern is **not random**, and the points are **clustered.**
:::

### 6.2 Using L-Function Estimation

In this section, I will be computing L-function via [Lest()](#0) of **spatstat** package which is normalises the K-function to a linear scale for easier interpretation.

#### **6.2.1 Yinmarbin District**

**1) Computing L-function Estimation**

```{r}
#| eval: false
L_yinmarbin = Lest(yinmarbin_ppp_owin, correction = "Ripley")
plot(L_yinmarbin, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
     main = paste("Yinmarbin District (L-Function)"))
```

![](images/clipboard-679889488.png){width="700"}

::: {.callout-tip title="Observations"}
The theoretical L-function under **CSR** **remains at** **0**, meaning that if the points were randomly distributed, the L-function would be expected to show no significant clustering or dispersion.

There is a consistent deviation of each observed L value from the theoretical value across all distances, particularly with the **strongest deviation at** **\<5 km and \> 20km**. This confirms that conflict points are both **localised** in towns of Yinmarbin and found across **large areas in Yinmarbin.**
:::

**2) Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

-   **Ho** = The distribution of conflict events in Myanmar are randomly distributed.
-   **H1**= The distribution of conflict events in Myanmar are not randomly distributed.
-   The null hypothesis will be rejected if the **observed L-function lies above/below** the theoretical L-function and envelope.

I will also perform monta carlo simulation test using **`envelope()`** of the¬†**spatstat**¬†package.

```{r}
#| eval: false
# Monte Carlo test with L-function
L_yinmarbin_csr <- envelope(yinmarbin_ppp_owin, Lest, 
                     nsim = 39, rank = 1, glocal=TRUE)
plot(L_yinmarbin_csr, . - r ~ r, xlab="d(km)", ylab="L(d)-r",
       main = paste("Yinmarbin District (CSR)"))
```

![](images/clipboard-3164642810.png){width="700"}

::: {.callout-tip title="Observations"}
The **envelope outputted is narrow** which once again reflects **lower variability** in spatial distribution in Yinmarbin where a large number of points found in this district could have led to more stable results. There is also **statistically significant clustering** particularly in specific towns in Yinmarbin and across Yinmarbin itself, since we see **larger deviations of observed L values** from the envelope.
:::

#### **6.2.2 Shwebo District**

**1) Computing L-function Estimation**

```{r}
#| eval: false
L_shwebo = Lest(shwebo_ppp_owin, correction = "Ripley")
plot(L_shwebo, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
     main = paste("Shwebo District (L-Function)"))
```

![](images/clipboard-1424827266.png){width="700"}

::: {.callout-tip title="Observations"}
The observed L values obtained for Shwebo districct tend to show a smaller deviation above the **theoretical L-function** in smaller areas like towns, suggesting **localised clustering is less pronounced.** Conversely, larger deviations are seen at larger distances which shows **broader patterns** of clustering are present in Shwebo district.
:::

**2) Performing Complete Spatial Randomness Test**

```{r}
#| eval: false
# Monte Carlo test with L-function
L_shwebo_csr <- envelope(shwebo_ppp_owin, Lest, 
                     nsim = 39, rank = 1, glocal=TRUE)
plot(L_shwebo_csr, . - r ~ r, xlab="d(km)", ylab="L(d)-r",
       main = paste("Shwebo District (CSR)"))
```

![](images/clipboard-1343711461.png){width="700"}

::: {.callout-tip title="Observations"}
The envelope size continues to grow larger as distance increases, which indicates greater variability in spatial patterns of the Shwebo district but overall, we can **confirm** **strong clustering** of conflicts especially in bigger areas of the district which suggests **wide-scale hotspots,** as well as some **localised clustering** at smaller scales.
:::

#### **6.2.3 Pakokku District**

**1) Computing L-function Estimation**

```{r}
#| eval: false
L_pakokku = Lest(pakokku_ppp_owin, correction = "Ripley")
plot(L_yinmarbin, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
     main = paste("Pakokku District (L-Function)"))
```

![](images/clipboard-129069972.png){width="700"}

::: {.callout-tip title="Observations"}
Like the other districts, there is clustering seen in Pakokku across smaller areas like towns and the distribution across the district itself.
:::

**2) Performing Complete Spatial Randomness Test**

```{r}
#| eval: false
# Monte Carlo test with L-function
L_pakokku_csr <- envelope(pakokku_ppp_owin, Lest, 
                     nsim = 39, rank = 1, glocal=TRUE)
```

![](images/clipboard-3364496780.png){width="700"}

::: {.callout-tip title="Observations"}
Under the CSR test, the **intensity of** **clustering weakens across larger distances (\>20km)** than we would have assumed in the previous step. This happens as Monte Carlo simulation accounts for random fluctuations especially at **larger distances** (e.g., \>20 km) where **random variability in the point pattern naturally increases.**

In short, **significant clustering** is present at **both small and large scales**, but with **diminishing intensity** as we measure larger distances.
:::

#### **6.2.4 Mandalay District**

**1) Computing L-function Estimation**

```{r}
#| eval: false
L_mandalay = Lest(mandalay_ppp_owin, correction = "Ripley")
plot(L_mandalay, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
     main = paste("Mandalay District (L-Function)"))
```

![](images/clipboard-1257608418.png){width="700"}

::: {.callout-tip title="Observations"}
The distance scale for Mandalay is the smallest (0-10km) since the district itself has a smaller area. Nonetheless, we see almost a **consistent spread of localised and widespread distribution** of conflict points in Mandalay which indicates that conflicts occur across both specific towns and the across the districct.
:::

**2) Performing Complete Spatial Randomness Test**

```{r}
#| eval: false
# Monte Carlo test with L-function
L_mandalay_csr <- envelope(mandalay_ppp_owin, Lest, 
                     nsim = 39, rank = 1, glocal=TRUE)
plot(L_mandalay_csr, . - r ~ r, xlab="d(km)", ylab="L(d)-r",
       main = paste("Mandalay District (CSR)"))
```

![](images/clipboard-2910906591.png){width="700"}

::: {.callout-tip title="Observations"}
The Monte Carlo simulation shows that there's **statistically significant clustering** across all distances since the observed L values consistently **lie above** the envelope. There is also a **marginal increase in variability** of random points observed which is inherent in larger distance scales as seen from the **slight widening of the envelope** as distance increases.
:::

## 7. 1st Order Spatio-Temporal Point Pattern Analysis

```{r}
#| code-fold: true
#| code-summary: Set up DayofYear variable per quarter
#| eval: true
Q2_2024 <- conflict_data_sf %>%
  filter(year_quarter == "2024 Q2") %>%
  mutate(DayofYear = yday(event_date))

Q1_2024 <- conflict_data_sf %>%
  filter(year_quarter == "2024 Q1") %>%
  mutate(DayofYear = yday(event_date))

Q4_2023 <- conflict_data_sf %>%
  filter(year_quarter == "2023 Q4") %>%
  mutate(DayofYear = yday(event_date))

Q3_2023 <- conflict_data_sf %>%
  filter(year_quarter == "2023 Q3") %>%
  mutate(DayofYear = yday(event_date))

Q2_2023 <- conflict_data_sf %>%
  filter(year_quarter == "2023 Q2") %>%
  mutate(DayofYear = yday(event_date))

Q1_2023 <- conflict_data_sf %>%
  filter(year_quarter == "2023 Q1") %>%
  mutate(DayofYear = yday(event_date))

Q4_2022 <- conflict_data_sf %>%
  filter(year_quarter == "2022 Q4") %>%
  mutate(DayofYear = yday(event_date))

Q3_2022 <- conflict_data_sf %>%
  filter(year_quarter == "2022 Q3") %>%
  mutate(DayofYear = yday(event_date))

Q2_2022 <- conflict_data_sf %>%
  filter(year_quarter == "2022 Q2") %>%
  mutate(DayofYear = yday(event_date))

Q1_2022 <- conflict_data_sf %>%
  filter(year_quarter == "2022 Q1") %>%
  mutate(DayofYear = yday(event_date))

Q4_2021 <- conflict_data_sf %>%
  filter(year_quarter == "2021 Q4") %>%
  mutate(DayofYear = yday(event_date))

Q3_2021 <- conflict_data_sf %>%
  filter(year_quarter == "2021 Q3") %>%
  mutate(DayofYear = yday(event_date))

Q2_2021 <- conflict_data_sf %>%
  filter(year_quarter == "2021 Q2") %>%
  mutate(DayofYear = yday(event_date))

Q1_2021 <- conflict_data_sf %>%
  filter(year_quarter == "2021 Q1") %>%
  mutate(DayofYear = yday(event_date))
```

### 7.1 **Creating ppp object**

In the code chunk below, **DayofYear** from the **fire_sf** data frame is selected and is included in the output ppp object.

```{r}
# Create ppp object per quarter
Q2_2024_ppp <- Q2_2024 %>% 
  select(DayofYear) %>%
  as.ppp()

Q1_2024_ppp <- Q1_2024 %>% 
  select(DayofYear) %>%
  as.ppp()

Q4_2023_ppp <- Q4_2023 %>% 
  select(DayofYear) %>%
  as.ppp()

Q3_2023_ppp <- Q3_2023 %>% 
  select(DayofYear) %>%
  as.ppp()

Q2_2023_ppp <- Q2_2023 %>% 
  select(DayofYear) %>%
  as.ppp()

Q1_2023_ppp <- Q1_2023 %>% 
  select(DayofYear) %>%
  as.ppp()

Q4_2022_ppp <- Q4_2022 %>% 
  select(DayofYear) %>%
  as.ppp()

Q3_2022_ppp <- Q3_2022 %>% 
  select(DayofYear) %>%
  as.ppp()

Q2_2022_ppp <- Q2_2022 %>% 
  select(DayofYear) %>%
  as.ppp()

Q1_2022_ppp <- Q1_2022 %>% 
  select(DayofYear) %>%
  as.ppp()

Q4_2021_ppp <- Q4_2021 %>% 
  select(DayofYear) %>%
  as.ppp()

Q3_2021_ppp <- Q3_2021 %>% 
  select(DayofYear) %>%
  as.ppp()

Q2_2021_ppp <- Q2_2021 %>% 
  select(DayofYear) %>%
  as.ppp()

Q1_2021_ppp <- Q1_2021 %>% 
  select(DayofYear) %>%
  as.ppp()
```

### 7.2 Combining ppp with owin object

Next, code chunk below is used to combine the ppp object and the owin object.

```{r}
# Mask the ppp object with owin object
Q2_2024_owin <- Q2_2024_ppp[myanmar_owin]

Q1_2024_owin <- Q1_2024_ppp[myanmar_owin]

Q4_2023_owin <- Q4_2023_ppp[myanmar_owin]

Q3_2023_owin <- Q3_2023_ppp[myanmar_owin]

Q2_2023_owin <- Q2_2023_ppp[myanmar_owin]

Q1_2023_owin <- Q1_2023_ppp[myanmar_owin]

Q4_2022_owin <- Q4_2022_ppp[myanmar_owin]

Q3_2022_owin <- Q3_2022_ppp[myanmar_owin]

Q2_2022_owin <- Q2_2022_ppp[myanmar_owin]

Q1_2022_owin <- Q1_2022_ppp[myanmar_owin]

Q4_2021_owin <- Q4_2021_ppp[myanmar_owin]

Q3_2021_owin <- Q3_2021_ppp[myanmar_owin]

Q2_2021_owin <- Q2_2021_ppp[myanmar_owin]

Q1_2021_owin <- Q1_2021_ppp[myanmar_owin]
```

Now, I will perform a **spatio-temporal kernel density estimate** on the `owin` object which gives us insights into where and when conflict event occurrences are concentrated within the specified observation window.

```{r}
#| code-fold: true
#| code-summary: Perform spatial temporal KDE per quarter
#| results: hide
library(spatstat)
Q2_2024_stkde <- spattemp.density(Q2_2024_owin)

Q1_2024_stkde <- spattemp.density(Q1_2024_owin)

Q4_2023_stkde <- spattemp.density(Q4_2023_owin)

Q3_2023_stkde <- spattemp.density(Q3_2023_owin)

Q2_2023_stkde <- spattemp.density(Q2_2023_owin)

Q1_2023_stkde <- spattemp.density(Q1_2023_owin)

Q4_2022_stkde <- spattemp.density(Q4_2022_owin)

Q3_2022_stkde <- spattemp.density(Q3_2022_owin)

Q2_2022_stkde <- spattemp.density(Q2_2022_owin)

Q1_2022_stkde <- spattemp.density(Q1_2022_owin)

Q4_2021_stkde <- spattemp.density(Q4_2021_owin)

Q3_2021_stkde <- spattemp.density(Q3_2021_owin)

Q2_2021_stkde <- spattemp.density(Q2_2021_owin)

Q1_2021_stkde <- spattemp.density(Q1_2021_owin)
```

### 7.3 Plotting STKDE Outputs

Let's plot our animated spatio-temporal KDE outputs for each quarter.

#### 7.3.1 2024 Q1-2 STKDE

```{r}
#| eval: false
library(spatstat)
library(magick)
library(viridis)

# 2024 Q2
frames <- image_read(list.files("STKDE/2024_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2024_Q2_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2024 Q1
frames <- image_read(list.files("STKDE/2024_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2024_Q1_stkde.gif){fig-align="center" width="500"}

::: {.callout-tip title="Observations"}
At the start of **2024 Q1**, we see that the kernel density estimate of Myanmar conflicts tend to **move sporadically** where there are no specific patterns but in **2024 Q2**, we start seeing conflict events occurring more intensely in **Central and Southern Myanmar**.
:::

#### 7.3.2 2023 Q1-Q4 STKDE

```{r}
#| eval: false
# 2023 Q4
frames <- image_read(list.files("STKDE/2023_Q4_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2023_Q4_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2023 Q3
frames <- image_read(list.files("STKDE/2023_Q3_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2023_Q3_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2023 Q2
frames <- image_read(list.files("STKDE/2023_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2023_Q2_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2023 Q1
frames <- image_read(list.files("STKDE/2023_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2023_Q1_stkde.gif){fig-align="center" width="500"}

::: {.callout-tip title="Observations"}
From **2023 Q1 to Q3**, there is a noticeable cluster of conflict events happening in **Central** and **Southern** regions of Myanmar than the other parts of the country. In **2023 Q4**, we can notice more dispersion in conflict events across Myanmar, spreading into **Western** and **Eastern** regions. Throughout 2023, conflict events are **least** **observed** in **North Myanmar.**
:::

#### 7.3.3 2022 Q1-Q4 STKDE

```{r}
#| eval: false
# 2022 Q4
frames <- image_read(list.files("STKDE/2022_Q4_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2022_Q4_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2022 Q3
frames <- image_read(list.files("STKDE/2022_Q3_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2022_Q3_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2022 Q2
frames <- image_read(list.files("STKDE/2022_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2022_Q2_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2022 Q1
frames <- image_read(list.files("STKDE/2022_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2022_Q1_stkde.gif){fig-align="center" width="500"}

::: {.callout-tip title="Observations"}
Similar to 2023, the spread of conflict events in **2022** is largely clustered in **Central** and **Southen parts of Myanmar.** However, we do see some jitters in conflict trends in **2022 Q1** with a **rare sight of conflicts** in the **far North** of Myanmar and **occasional conflicts** in **Southern** Myanmar.
:::

#### 7.3.4 2021 Q1-Q4 STKDE

```{r}
#| eval: false
# 2021 Q4
frames <- image_read(list.files("STKDE/2021_Q4_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2021_Q4_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2021 Q3
frames <- image_read(list.files("STKDE/2021_Q3_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2021_Q3_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2021 Q2
frames <- image_read(list.files("STKDE/2021_Q2_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2021_Q2_stkde.gif){fig-align="center" width="500"}

```{r}
#| eval: false
# 2021 Q1
frames <- image_read(list.files("STKDE/2021_Q1_frames", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 10) 
animation
```

![](STKDE/2021_Q1_stkde.gif){fig-align="center" width="500"}

::: {.callout-tip title="Observations"}
Finally, armed conflicts in **2021** is by far the **most random spread** of armed conflicts throughout Myanmar. There is also a high intensity of conflicts in South Myanmar, particularly in the **state of Yangon** while we **rarely** see conflicts occurring in the **extreme** **North** of Myanmar.
:::

#### 7.3.5 OpenStreetMap in Myanmar - Spatio Temporal

We can observe the spatio-temporal conflict patterns per quarter using OpenStreetMap as well.

```{r}
#| echo: true
#| warning: false
Q2_2024_owin <- rescale(Q2_2024_owin, 1000, "km")
Q2_2024_stkde <- density(Q2_2024_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q1_2024_owin <- rescale(Q1_2024_owin, 1000, "km")
Q1_2024_stkde <- density(Q1_2024_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q4_2023_owin <- rescale(Q4_2023_owin, 1000, "km")
Q4_2023_stkde <- density(Q4_2023_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q3_2023_owin <- rescale(Q3_2023_owin, 1000, "km")
Q3_2023_stkde <- density(Q3_2023_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q2_2023_owin <- rescale(Q2_2023_owin, 1000, "km")
Q2_2023_stkde <- density(Q2_2023_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q1_2023_owin <- rescale(Q1_2023_owin, 1000, "km")
Q1_2023_stkde <- density(Q1_2023_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q4_2022_owin <- rescale(Q4_2022_owin, 1000, "km")
Q4_2022_stkde <- density(Q4_2022_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q3_2022_owin <- rescale(Q3_2022_owin, 1000, "km")
Q3_2022_stkde <- density(Q3_2022_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q2_2022_owin <- rescale(Q2_2022_owin, 1000, "km")
Q2_2022_stkde <- density(Q2_2022_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q1_2022_owin <- rescale(Q1_2022_owin, 1000, "km")
Q1_2022_stkde <- density(Q1_2022_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q4_2021_owin <- rescale(Q4_2021_owin, 1000, "km")
Q4_2021_stkde <- density(Q4_2021_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q3_2021_owin <- rescale(Q3_2021_owin, 1000, "km")
Q3_2021_stkde <- density(Q3_2021_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q2_2021_owin <- rescale(Q2_2021_owin, 1000, "km")
Q2_2021_stkde <- density(Q2_2021_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
Q1_2021_owin <- rescale(Q1_2021_owin, 1000, "km")
Q1_2021_stkde <- density(Q1_2021_owin, sigma=bw.CvL, edge=TRUE, kernel="quartic")
```

```{r}
#| code-fold: true
#| code-summary: Set up raster and projection
#| warning: false
raster_Q2_2024 <- raster(Q2_2024_stkde)
raster_Q1_2024 <- raster(Q1_2024_stkde)
raster_Q4_2023 <- raster(Q4_2023_stkde)
raster_Q3_2023 <- raster(Q3_2023_stkde)
raster_Q2_2023 <- raster(Q2_2023_stkde)
raster_Q1_2023 <- raster(Q1_2023_stkde)
raster_Q4_2022 <- raster(Q4_2022_stkde)
raster_Q3_2022 <- raster(Q3_2022_stkde)
raster_Q2_2022 <- raster(Q2_2022_stkde)
raster_Q1_2022 <- raster(Q1_2022_stkde)
raster_Q4_2021 <- raster(Q4_2021_stkde)
raster_Q3_2021 <- raster(Q3_2021_stkde)
raster_Q2_2021 <- raster(Q2_2021_stkde)
raster_Q1_2021 <- raster(Q1_2021_stkde)
projection(raster_Q2_2024) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q1_2024) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q4_2023) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q3_2023) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q2_2023) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q1_2023) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q4_2022) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q3_2022) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q2_2022) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q1_2022) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q4_2021) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q3_2021) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q2_2021) <- CRS("+init=EPSG:32647 +units=km")
projection(raster_Q1_2021) <- CRS("+init=EPSG:32647 +units=km")
```

```{r}
# Plot KDE Map on OpenStreetMap
raster_quarters <- list('raster_Q2_2024','raster_Q1_2024','raster_Q4_2023','raster_Q3_2023','raster_Q2_2023','raster_Q1_2023','raster_Q4_2022','raster_Q3_2022','raster_Q2_2022','raster_Q1_2022','raster_Q4_2021','raster_Q3_2021','raster_Q2_2021','raster_Q1_2021')

# Set tmap mode to view
tmap_mode('view')

# Function to create tmap for each raster
create_tmap <- function(raster_var) {
  kde_fixed_output <- tm_basemap(server = "OpenStreetMap.HOT") +
    tm_basemap(server = "Esri.WorldImagery") +
    tm_shape(get(raster_var)) +  # Dynamically get the raster variable
    tm_raster("layer",
              n = 10,
              title = paste(raster_var),
              alpha = 0.6,
              palette = c("#fafac3","#fd953b","#f02a75","#b62385","#021c9e")) +
    tm_shape(boundary_sf) +
    tm_polygons(alpha=0.1, id="DT") +
    tmap_options(check.and.fix = TRUE)
  
  return(kde_fixed_output)
}

# Create a list of tmap objects by iterating over the raster_quarters list
tmap_list <- lapply(raster_quarters, create_tmap)

# Arrange and display the tmaps
tmap_arrange(tmap_list, ncol = 2, nrow = 2, sync = TRUE)

tmap_mode("plot")
```

::: {.callout-tip title="Observations"}
The plots uncover the increasing levels of conflicts across each quarter. Interestingly, **2021 Q1** begins with higher concentration of armed conflicts in **Southern** and **Eastern** parts of Myanmar, but gradually becomes more concentrated in the **Central districts**. From **2022 Q4 onwards**, we see that conflicts have spread **outside the core central region** of Myanmar towards the **Western region.** Conflicts return to occurring more frequently in the Central districts like Yinmarbin and Sagaing in **2024 Q1 and Q2,**
:::

## 8. 2nd Order Spatio-Temporal Point Pattern Analysis

Similar to the 2nd order spatial analysis in section 6, I want to explore **spatio-temporal trends** of Myanmar's conflicts and how the events differ in distribution, from **quarter to quarter.** I'll delve into the **four districts** I'm most interested in, that is the districts with the **highest proportions of conflicts** - Yinmarbin, Shwebo, Pakokku and Mandalay.

### 8.1 Using K-Function Estimation

#### 8.1.1 Yinmarbin District

We'll want to compute the **K-Function by quarters** via **`Kest()`** by iterating over each unique quarter in **date format**, then plotting an **animated graph** of the K-Function outputs **per quarter.**

**1) Computing K-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Prepare Dataset for Yinmarbin District
# Set up yinmarbin_ppp_owin_list
conflict_yinmarbin <- conflict_data_sf %>% filter(DT == "Yinmarbin")
unique_quarter <- unique(conflict_yinmarbin$year_quarter)
boundary_yinmarbin <- filter(boundary_sf, DT == "Yinmarbin")
yinmarbin_owin <- as.owin(boundary_yinmarbin)
yinmarbin_ppp_owin_list <- list()

for (quarter in unique_quarter) {
  quarter_data <- conflict_yinmarbin %>% 
    filter(year_quarter == quarter)

  ppp_obj <- as.ppp(quarter_data$geometry)
  ppp_owin_obj <- ppp_obj[yinmarbin_owin]
  ppp_owin_obj_km <- rescale(ppp_owin_obj, 1000, "km")
  yinmarbin_ppp_owin_list[[quarter]] <- ppp_owin_obj_km
}
```

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot K-function for Yinmarbin District
library(magick)

# Create a directory to store PNG frames
path <- file.path("sec_order_k_function", "conflict_yinmarbin")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(yinmarbin_ppp_owin_list)) {
  ppp_owin_obj_km <- yinmarbin_ppp_owin_list[[quarter]]
  K_result <- Kest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_k_function/conflict_yinmarbin", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, . -r ~ r, ylab= "K(d)-r", xlab = "d(km)",
       main = paste("Yinmarbin District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_k_function/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_k_function/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)
```

![](sec_order_k_function/kfunction_yinmarbin.gif)

::: {.callout-tip title="Observations"}
We can observe how the **observed line (K-iso)** is constantly above the **actual line (K-pois)** from **2021 Q2 to 2024 Q2**. This confirms that conflict points in **Yinmarbin** are **highly clustered**. In fact, it is more clustered together than expected by the null hypothesis. There is no K-function outputted for **2021 Q1** as **no conflict points** were observed in Yinmarbin District for that time period.
:::

::: callout-note
**Ripley‚Äôs Correction** provides a way to **mitigate the bias** introduced by points near the edge of the study window by accounting for the reduced area for point comparisons near the edges. Hence, this results in a a **more accurate estimate** of the spatial distribution as seen in the **slight difference between actual and expected K-function.**
:::

**2) Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test (i.e. Monta Carlo simulation test) will be conducted. The hypothesis and test are as follows:

-   **Ho** = The distribution of conflict events in Myanmar are randomly distributed.
-   **H1**= The distribution of conflict events in Myanmar are not randomly distributed.
-   The null hypothesis will be rejected if the **observed K-function lies above/below** the theoretical K-function and envelope.

By using **`envelop()`**, we can get a more robust interpretation by comparing the observed K-function against a simulation envelope of K-functions generated under the null hypothesis.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Yinmarbin District
library(magick)

# Unique quarters of the year in the dataset
unique_quarter <- unique(conflict_yinmarbin$year_quarter)

# Create a directory to store PNG frames
path <- file.path("k_function_monta_carlo", "conflict_yinmarbin")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(yinmarbin_ppp_owin_list)) {
  ppp_owin_obj_km <- yinmarbin_ppp_owin_list[[quarter]]
  
  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("k_function_monta_carlo/conflict_yinmarbin", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Yinmarbin District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("k_function_monta_carlo/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "k_function_monta_carlo/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)
```

![](k_function_monta_carlo/kfunction_yinmarbin.gif)

::: {.callout-tip title="Observations"}
I noticed that the observed line has a **somewhat substantial** **deviation** above the **upper** **envelop** (shaded region) generated from the Monte Carlo simulation. This indicates a **strong** **tendancy** for points to be **clustered** in the **Yinmarbin district.** Since this occurs across a wide range of distances, it implies that **clustering is a prominent feature** of the spatial distribution.
:::

#### 8.1.2 Shwebo District

**1) Computing K-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Prepare Dataset for Shwebo District
# Set up shwebo_ppp_owin_list
conflict_shwebo <- conflict_data_sf %>% filter(DT == "Shwebo")
unique_quarter <- unique(conflict_shwebo$year_quarter)
boundary_shwebo <- filter(boundary_sf, DT == "Shwebo")
shwebo_owin <- as.owin(boundary_shwebo)
shwebo_ppp_owin_list <- list()

for (quarter in unique_quarter) {
  quarter_data <- conflict_shwebo %>% 
    filter(year_quarter == quarter)

  ppp_obj <- as.ppp(quarter_data$geometry)
  ppp_owin_obj <- ppp_obj[shwebo_owin]
  ppp_owin_obj_km <- rescale(ppp_owin_obj, 1000, "km")
  shwebo_ppp_owin_list[[quarter]] <- ppp_owin_obj_km
}
```

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot K-function for Shwebo District
library(magick)

# Unique quarters of the year in the dataset
unique_quarter <- unique(conflict_shwebo$year_quarter)

# Create a directory to store PNG frames
path <- file.path("sec_order_k_function", "conflict_shwebo")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(shwebo_ppp_owin_list)) {
  ppp_owin_obj_km <- shwebo_ppp_owin_list[[quarter]]
  
  # Calculate the K-function
  K_result <- Kest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_k_function/conflict_shwebo", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, . -r ~ r, ylab= "K(d)-r", xlab = "d(km)",
       main = paste("Shwebo District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_k_function/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_k_function/kfunction_shwebo.gif"
image_write(animation, path = output_path)
```

![](sec_order_k_function/kfunction_shwebo.gif)

::: {.callout-tip title="Observations"}
For the Shwebo District, the **observed line (K-iso)** also lies constantly above the **actual line (K-pois)** from **2021 Q2 to 2024 Q2**, indicating **clustering** at all distances 'r' of our spatial points. Interestingly, conflict events in **2021 Q1 displayed some tendancy towards a dispersed point pattern** as the observed K-function lies **slightly below** the actual line at a distance of 17km.
:::

**2) Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test (i.e. Monta Carlo simulation test) will be conducted.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Shwebo District
# Create a directory to store PNG frames
path <- file.path("k_function_monta_carlo", "conflict_shwebo")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(shwebo_ppp_owin_list)) {
  ppp_owin_obj_km <- shwebo_ppp_owin_list[[quarter]]

  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("k_function_monta_carlo/conflict_shwebo", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Shwebo District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("k_function_monta_carlo/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "k_function_monta_carlo/kfunction_shwebo.gif"
image_write(animation, path = output_path)
```

![](k_function_monta_carlo/kfunction_shwebo.gif)

::: {.callout-tip title="Observations"}
In **2021 Q1,** a sharp jagged plot is generated due to the smaller dataset size of conflicts in Shwebo. In **2024 Q2,** we see the **highest variability** in spatial patterns which results in a larger envelope size

Generally, the observed line has a **smaller** **deviation** above the **upper** **envelop** than in the Yinmarbin data. This indicates a **a somewhat intense level of clustering** in the Shwebo district and remains more clustered than would be expected if points were distributed randomly..
:::

#### 8.1.3 Pakokku District

**1) Computing K-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Prepare Dataset for Pakokku District
# Set up pakokku_ppp_owin_list
conflict_pakokku <- conflict_data_sf %>% filter(DT == "Pakokku")
unique_quarter <- unique(conflict_pakokku$year_quarter)
boundary_pakokku <- filter(boundary_sf, DT == "Pakokku")
pakokku_owin <- as.owin(boundary_pakokku)
pakokku_ppp_owin_list <- list()

for (quarter in unique_quarter) {
  quarter_data <- conflict_pakokku %>% 
    filter(year_quarter == quarter)

  ppp_obj <- as.ppp(quarter_data$geometry)
  ppp_owin_obj <- ppp_obj[pakokku_owin]
  ppp_owin_obj_km <- rescale(ppp_owin_obj, 1000, "km")
  pakokku_ppp_owin_list[[quarter]] <- ppp_owin_obj_km
}
```

![](sec_order_k_function/kfunction_pakokku.gif)

::: {.callout-tip title="Observations"}
The observed K-function **lies above** the expected K-function outputted from 2021 to 2024**,** indicating **clustering** at all distances 'r' of our spatial points. However, we can observe **milder clustering** from **2021 Q4 to 2024 Q2** as the **magnitude of deviation is significantly smaller** than the period of **2021 Q1 to 2021 Q3.**
:::

**2) Performing Complete Spatial Randomness Test**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Pakokku District
# Create a directory to store PNG frames
path <- file.path("k_function_monta_carlo", "conflict_pakokku")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(pakokku_ppp_owin_list)) {
  ppp_owin_obj_km <- pakokku_ppp_owin_list[[quarter]]
  
  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("k_function_monta_carlo/conflict_pakokku", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Pakokku District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("k_function_monta_carlo/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "k_function_monta_carlo/kfunction_pakokku.gif"
image_write(animation, path = output_path)
```

![](k_function_monta_carlo/kfunction_pakokku.gif)

::: {.callout-tip title="Observations"}
In **2021 Q2,** we see a **large envelope** which reflects greater variability in the expected K-function and this could stem from the **mix of both clustering and dispersion** across Myanmar for that period. Generally from **2021 Q1 to 2024 Q2,** clustering is evident as the observed K-function continues to lie above the envelope.
:::

#### 8.1.4 Mandalay District

**1) Computing K-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Prepare Dataset for Mandalay District
# Set up mandalay_ppp_owin_list
conflict_mandalay <- conflict_data_sf %>% filter(DT == "Mandalay")
unique_quarter <- unique(conflict_mandalay$year_quarter)
boundary_mandalay <- filter(boundary_sf, DT == "Mandalay")
mandalay_owin <- as.owin(boundary_mandalay)
mandalay_ppp_owin_list <- list()

for (quarter in unique_quarter) {
  quarter_data <- conflict_mandalay %>% 
    filter(year_quarter == quarter)

  ppp_obj <- as.ppp(quarter_data$geometry)
  ppp_owin_obj <- ppp_obj[mandalay_owin]
  ppp_owin_obj_km <- rescale(ppp_owin_obj, 1000, "km")
  mandalay_ppp_owin_list[[quarter]] <- ppp_owin_obj_km
}
```

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot K-function for Mandalay District
library(magick)
# Create a directory to store PNG frames
path <- file.path("sec_order_k_function", "conflict_mandalay")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(mandalay_ppp_owin_list)) {
  ppp_owin_obj_km <- mandalay_ppp_owin_list[[quarter]]
  
  # Calculate the K-function
  K_result <- Kest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_k_function/conflict_mandalay", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, . -r ~ r, ylab= "K(d)-r", xlab = "d(km)",
       main = paste("Mandalay District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_k_function/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_k_function/kfunction_mandalay.gif"
image_write(animation, path = output_path)
```

![](sec_order_k_function/kfunction_mandalay.gif)

::: {.callout-tip title="Observations"}
The degree of **clustering** **is less pronounced** in Mandalay than the other districts since the **gap** between the observed line and the theoretical line is smaller. Clustering is **large-scale** in Mandalay where statistically significant clustering patterns are seen in larger distance ranges.
:::

**2) Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test (i.e. Monta Carlo simulation test) will be conducted.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Mandalay District
library(magick)
# Create a directory to store PNG frames
path <- file.path("k_function_monta_carlo", "conflict_mandalay")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the K-function
for (quarter in names(mandalay_ppp_owin_list)) {
  ppp_owin_obj_km <- mandalay_ppp_owin_list[[quarter]]

  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("k_function_monta_carlo/conflict_mandalay", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Mandalay District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("k_function_monta_carlo/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "k_function_monta_carlo/kfunction_mandalay.gif"
image_write(animation, path = output_path)
```

![](k_function_monta_carlo/kfunction_mandalay.gif)

::: {.callout-tip title="Observations"}
We see the highest variability in spatial patterns in **2024 Q1 and Q2** which indicates that **some areas** in Mandalay District are **more clustered** with conflict events while other areas are **more evenly spaced.**

We can confirm **statistically significant clustering** from **2021 Q1 to 2023 Q3** as K value is larger than the upper confidence of the envelope than in **2024 Q1 and Q2.** There is also strong evidence of clustering especially at larger distances which means Mandalay District faces **large-scale clustering.**
:::

### 8.2 Using L-Function Estimation

#### 8.2.1 Yinmarbin District

**1) Computing L-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot L-function for Yinmarbin District
library(magick)
# Create a directory to store PNG frames
path <- file.path("sec_order_L_function", "conflict_yinmarbin")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(yinmarbin_ppp_owin_list)) {
  ppp_owin_obj_km <- yinmarbin_ppp_owin_list[[quarter]]
  
  # Calculate the L-function
  L_result <- Lest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_L_function/conflict_yinmarbin", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(L_result, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
       main = paste("Yinmarbin District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_L_function/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_L_function/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)
```

![](sec_order_L_function/kfunction_yinmarbin.gif)

::: {.callout-tip title="Observations"}
Firstly, the L-function plot **appears more zig-zag** than the K-function as the L-function can **magnify small fluctuations** in the K-function. Secondly, the theoretical line (dotted) is fixed at 0 where L(d)‚àír=0 which is an expected behavior under **Complete Spatial Randomness**.

From **2022 Q1- Q3, all of 2023 and 2024 Q2,** there is **large scale clustering** as the observed line (K-iso) consistently **lies above** the theoretical line (K-pois) particularly at **larger spatial distances**. This suggests conflicts in Yinmarbin are **clustered** across the district during this time period.

From **2021, 2022 Q4 and 2024 Q1,** there is a decreasing K value observed which indicates more **localised clustering** **in specific towns** on Yinmarbin.
:::

**2) Performing Complete Spatial Randomness Test**

I will also perform monta carlo simulation test using **`envelope()`** of the¬†**spatstat**¬†package.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Yinmarbin District
library(magick)
# Create a directory to store PNG frames
path <- file.path("L_function_monta_carlo", "conflict_yinmarbin")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(yinmarbin_ppp_owin_list)) {
  ppp_owin_obj_km <- yinmarbin_ppp_owin_list[[quarter]]

  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("L_function_monta_carlo/conflict_yinmarbin", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Yinmarbin District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("L_function_monta_carlo/conflict_yinmarbin", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "L_function_monta_carlo/kfunction_yinmarbin.gif"
image_write(animation, path = output_path)
```

![](L_function_monta_carlo/kfunction_yinmarbin.gif)

::: {.callout-tip title="Observations"}
The periods of 2022 Q4, 2024 Q1 and 2024 Q2 shows a wider envelope which indicates that **some areas are clustered** while **others are more evenly spaced** in Yinmarbin. There's also more **widespread** **clustering** observed in **all of** **2023** and in **2024 Q2** where deviation of L values above the envelope are signifiantly larger at bigger distances scales.
:::

#### 8.2.2 Shwebo District

**1) Computing L-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot L-function for Shwebo District
library(magick)
# Create a directory to store PNG frames
path <- file.path("sec_order_L_function", "conflict_shwebo")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(shwebo_ppp_owin_list)) {
  ppp_owin_obj_km <- shwebo_ppp_owin_list[[quarter]]
  
  # Calculate the L-function
  L_result <- Lest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_L_function/conflict_shwebo", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(L_result, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
       main = paste("Shwebo District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_L_function/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_L_function/kfunction_shwebo.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("sec_order_L_function/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](sec_order_L_function/kfunction_shwebo.gif)

::: {.callout-tip title="Observations"}
The **2021 Q1** observed L values are much **more** **jagged** than other quarters as we have a smalller dataset of conflicts in Shwebo district of that quarter. In general, we see stronger clustering in bigger areas of the district which suggests **wide-scale clustering** of conflicts.
:::

**2) Performing Complete Spatial Randomness Test**

I will also perform monta carlo simulation test using **`envelope()`** of the¬†**spatstat**¬†package.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Shwebo District
library(magick)
# Create a directory to store PNG frames
path <- file.path("L_function_monta_carlo", "conflict_shwebo")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(shwebo_ppp_owin_list)) {
  ppp_owin_obj_km <- shwebo_ppp_owin_list[[quarter]]
  
  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("L_function_monta_carlo/conflict_shwebo", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Shwebo District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("L_function_monta_carlo/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "L_function_monta_carlo/kfunction_shwebo.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("L_function_monta_carlo/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](L_function_monta_carlo/kfunction_shwebo.gif)

::: {.callout-tip title="Observations"}
**2021 Q2** and **2024 Q2** has the highest variability in spatial points with both clustering and dispersion patterns under the CRS test in Shwebo district. Nonetheless, we can confirm **strong significance of widespread clustering** **of conflicts** throughout all quarters in Shwebo where the observed L values like above the theoretical values simulated, particularly at larger distance scales.
:::

#### 8.2.3 Pakokku District

**1) Computing L-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot L-function for Pakokku District
# Create a directory to store PNG frames
path <- file.path("sec_order_L_function", "conflict_pakokku")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(pakokku_ppp_owin_list)) {
  ppp_owin_obj_km <- pakokku_ppp_owin_list[[quarter]]
  
  # Calculate the L-function
  L_result <- Lest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_L_function/conflict_pakokku", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(L_result, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
       main = paste("Pakokku District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_L_function/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_L_function/kfunction_pakokku.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("sec_order_L_function/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](sec_order_L_function/kfunction_pakokku.gif)

::: {.callout-tip title="Observations"}
We generally see **strong evidence** of **localised clustering** in the Pakokku district with **weaker significance of clustering in bigger distance scales.** This means that **specific towns in Pakokku** have more intense hotspots than others.It is worth noting that the jagged ouputs from the observed L values in **2021 Q1 and Q2** stems from our smaller data conflict points for these periods.
:::

**2) Performing Complete Spatial Randomness Test**

I will also perform monta carlo simulation test using **`envelope()`** of the¬†**spatstat**¬†package.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Pakokku District
# Create a directory to store PNG frames
path <- file.path("L_function_monta_carlo", "conflict_pakokku")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(pakokku_ppp_owin_list)) {
  ppp_owin_obj_km <- pakokku_ppp_owin_list[[quarter]]

  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("L_function_monta_carlo/conflict_pakokku", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Pakokku District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("L_function_monta_carlo/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "L_function_monta_carlo/kfunction_pakokku.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("L_function_monta_carlo/conflict_pakokku", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](L_function_monta_carlo/kfunction_pakokku.gif){width="500"}

::: {.callout-tip title="Observations"}
The results of the simulation produces the greatest variability in conflict activity in Pakokku in **2021 Q2** and **2024 Q1.** The CSR tests confirms **significant clustering** throughout all quarters in Pakokku. We can confirm that **localised clustering** are more promoinent in **2021 Q2, 2022 Q3** and **2024 Q1** where the L-values deviates more above the envelope at smaller distances. The remaning quarters show strong evidence of **widespread** **clustering** across a bigger distribution of Pakokku district.
:::

#### 8.2.4 Mandalay District

**1) Computing L-function Estimation**

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Plot L-function for Mandalay District
library(magick)
# Create a directory to store PNG frames
path <- file.path("sec_order_L_function", "conflict_mandalay")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(mandalay_ppp_owin_list)) {
  ppp_owin_obj_km <- mandalay_ppp_owin_list[[quarter]]
  
  # Calculate the L-function
  L_result <- Lest(ppp_owin_obj_km, correction = "Ripley")

  # Create PNG filename
  png_filename <- file.path("sec_order_L_function/conflict_mandalay", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(L_result, . -r ~ r, ylab= "L(d)-r", xlab = "d(km)",
       main = paste("Mandalay District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("sec_order_L_function/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "sec_order_L_function/kfunction_mandalay.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("sec_order_L_function/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](sec_order_L_function/kfunction_mandalay.gif){width="500"}

::: {.callout-tip title="Observations"}
Generally from 2021 to 2024, we see an **upward trend** of observed L values with sharp fluctuations as distance increases.

At both small and large distance scales, we can observe **deviations** of the observed line above the theoretical line which suggests **statistically strong** evidence of **clustering across Mandalay,** where clustering is **present at local towns and across Mandalay.**
:::

**2) Performing Complete Spatial Randomness Test**

I will also perform monta carlo simulation test using **`envelope()`** of the¬†**spatstat**¬†package.

```{r}
#| code-fold: true
#| eval: false
#| code-summary: Monta Carlo Simulation for Mandalay District
# Create a directory to store PNG frames
path <- file.path("L_function_monta_carlo", "conflict_mandalay")
if (!dir.exists(path)) {
  dir.create(path, recursive = TRUE)
}

# Loop through each unique quarter and plot the L-function
for (quarter in names(mandalay_ppp_owin_list)) {
  ppp_owin_obj_km <- mandalay_ppp_owin_list[[quarter]]
  
  # Calculate the envelope
  K_result <- envelope(ppp_owin_obj_km, Kest, nsim = 39, 
                       rank = 1, glocal=TRUE)
  # Create PNG filename
  png_filename <- file.path("L_function_monta_carlo/conflict_mandalay", 
                            sprintf("frame_%s.png", quarter))
  
  # Save the plot as PNG
  png(filename = png_filename, width = 800, height = 800)
  plot(K_result, 
       main = paste("Mandalay District -",quarter))
  dev.off()
}

# Read all PNG files from the frames directory
frames <- image_read(list.files("L_function_monta_carlo/conflict_mandalay", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1)
output_path <- "L_function_monta_carlo/kfunction_mandalay.gif"
image_write(animation, path = output_path)
```

```{r}
#| eval: false
# Display Plot
frames <- image_read(list.files("L_function_monta_carlo/conflict_shwebo", full.names = TRUE, pattern = "*.png"))
animation <- image_animate(image_join(frames), fps = 1) 
animation
```

![](L_function_monta_carlo/kfunction_mandalay.gif){width="500"}

::: {.callout-tip title="Observations"}
In 2021 Q1 and 2024 Q1-2, we can observe a **bigger envelope** from the CSR test especially at **larger distances**. This means certain areas in Mandalay show strong clustering (hotspots), while others are more dispersed, leading to **greater variability** in the overall spatial structure of conflict events.

Additionally, throughout 2021 to 2024, there is **prominent evidence of hotspots and clustering** throughout Mandalay since observed L values deviate above the theoretical L values, across a range of distances.
:::

## 9. Conclusion

My analysis has revealed how **central districts** (i.e., Yinmarbin, Shwebo, Pakokku and Mandalay) and **western states** (i.e. Yangon) have experienced intense clashes between **state forces and politica/identity militias**, while **northern Myanmar** sees high conflict levels between **rebels and political militias**. However, one should also consider the size of a state/district when computing KDE since a smaller area could increase the density of conflict **quite significantly.**

The **political militia** are found to be less involved with unarmed civilians than state forces, rebels and other policial militia. Conversely, civilians are seen to be embroiled mostly in conflicts resulting from **strategic development** and **violence against civilians events,** primarily in Central and Western Myanmar. Fortunately, conflicts involving **explosions or remote violence is not as intense** against civilians but this raises a great concern on the **humanitarian crisis** faced by civilians in Myanmar, especially since armed conflicts tend to **occur repeatedly** in the **same parts of each state** which indicates an **unceasing cycle of conflicts in Myanmar.**

Additionally, results from the Monte Carlo CSR test indicated a **strong** **tendency** for points to be **clustered** across a wide range of distances, implying that **clustering is a prominent feature** of the spatial distribution in districts like Sagaing, Mandalay, Magway and Yangon. Conversely, there are **specific conflict hot spots** observed in certain towns of the district which means **localised clustering are also present.**

It can also be derived that in **2021 Q1 and Q2**, conflict points are **less intense and slightly more random** in its distribution. The intensity of conflicts continue to soar from **2022 Q1 to 2024 Q2** with both **localised and widespread** conflict events during these period of time.

## 10. My Reflections

This take-home exercise has significantly **expanded my understanding** and **underscored the severe humanitarian conflicts** in Myanmar, revealed through this spatial and spatio-temporal point pattern analysis.

A key takeaway from Myanmar‚Äôs humanitarian conflict is how complex the interplay of ethnic, political, and religious struggles has been and continues to be an **on-going humanitarian crisis**, involving the **military, ethnic armed groups, political militias, and civilians.**

Lastly, running **computationally intensive codes** such as **`envelope()`** for 2nd order spatial analysis may differ in processing speed from one student to another. My system, however, is running with **8 cores** and it does take a **lengthy amount of time** for processing the large 40,000+ rows of conflict data.

Hence, I would suggest other students to **begin their take-home exercise as early as possible** to provide buffer time for processing the data, handling code bugs and even data cleaning errors.

## 11. References

1.  Crawley, M. J. (2007). The R Book. Wiley.

2.  Crisis Group. (2024, August 27). Breaking Away: The Battle for Myanmar‚Äôs Rakhine State. <https://www.crisisgroup.org/asia/south-east-asia/myanmar/339-breaking-away-battle-myanmars-rakhine-state>¬†

3.  Farge, E., & Mantovani, C. (2024, September 17). Myanmar military stepping up civilian killings and arrests, says UN report. <https://www.reuters.com/world/asia-pacific/myanmar-military-intensifies-civilian-killings-arrests-says-un-report-2024-09-17/#:~:text=The%20report%20by%20the%20United,the%20military%20since%20the%20coup>.¬†

4.  Fishbein, E., & Lusan, N. N. (2022, December 14). 'Afraid of the gun': Military coup fuels Myanmar resource grab. Al Jazeera. <https://www.aljazeera.com/news/2022/12/14/afraid-of-the-gun-military-coup-fuels-myanmar-resource-grab>¬†

5.  Rajagopalan, B., Lall, U., & Tarboton, D. (1997). Evaluation of kernel density estimation methods for daily precipitation resampling. Springer-Verlag.

6.  Shen, B., Xiang Xu, Plaza, A., & Huang, Q. (2020, November 15). Unfolding Spatial-Temporal Patterns of Taxi Trip based on an Improved Network Kernel Density Estimation. MDPI. Retrieved September 22, 2024, from <https://www.mdpi.com/2220-9964/9/11/683>¬†

7.  The Stata Journal. (2003). Adaptive kernel density estimation. Sage Journals. <https://journals.sagepub.com/doi/pdf/10.1177/1536867X0300300204>
