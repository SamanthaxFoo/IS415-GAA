---
title: "Take-home Exercise 2"
subtitle: "Harnessing Geospatial Methods to Analyse Drug Abuse Patterns in Thailand"
author: "Foo Jia Yi Samantha"
date-modified: 10/06/2024
date: 10/06/2024
format: 
  html:
    toc-depth: 5
execute: 
  eval: true
  echo: true
  freeze: true
---

## **1. Setting the Scene: Drug Abuse in Thailand**

In 2022, **567,609 drug users in ASEAN** were treated, in which Thailand was found to have the **highest number of drug users requiring treatment** among ASEAN countries, followed by Malaysia, Indonesia, Laos, the Philippines, and Singapore. (Kahanto M., et al, 2022) Drug abuse is a significant social issue in Thailand, with profound health, financial, and societal implications. Positioned near the Golden Triangle—one of the largest drug production areas in Asia—Thailand faces ongoing challenges due to its geographical proximity and extensive transportation routes, which facilitate drug trafficking. Within Thailand, drug abuse is particularly **prevalent among the youth**, with approximately **2.7 million young people involved**. Of those aged 15–19, around **300,000 are in need of drug treatment**, and vocational students are disproportionately affected compared to their peers in secondary school.

This underscores the importance of drug treatment in addressing the complex problem of substance abuse and reduces the societal costs associated with drug abuse, such as healthcare expenses, lost productivity, and crime. Hence, to better allocate resources and develop targeted interventions, it is **crucial to understand where drug abuse is most concentrated and how it spreads geographically.** This is where geospatial analysis becomes essential. 

In this exercise, I will utilise geospatial analysis methods to explore the province-level dynamics of drug abuse in Thailand. This will involve preparing a study area layer as `sf` polygon features at the province level, including Bangkok, and creating a drug abuse indicators layer within this study area. Using these extracted data layers, I will conduct **global spatial autocorrelation analysis** using `sfdep` methods, followed by **local spatial autocorrelation analysis.** Finally, I will describe the spatial patterns revealed by determining whether key indicators are spatially dependent, and identifying trends of clusters, outliers and hotspots over time.

## **2. Methods Used**

### **2.1 Spatial Autocorrelation**

![](images/clipboard-1506008753.png){fig-align="center"}

This quote from Tobler (1970) highlights the essence of spatial autocorrelation, emphasising the importance of studying how values of the same variable are interconnected across space. By examining spatial dependence, we can better understand local and global patterns and variations. This law suggests that phenomena that are geographically close to each other are more likely to be similar or have some kind of spatial relationship compared to phenomena that are farther apart. 

It is also important to note that spatial structure and spatial autocorrelation are inherently interconnected (Tiefelsdorf, 1998):

-   **Spatial structure** encompasses all the connections through which the autocorrelated phenomenon spreads.

-   Without a significant autocorrelated process, spatial structure **cannot be empirically observed.**

Thus, the observed spatial distribution is regarded as a reflection of the underlying spatial process. When spatial autocorrelation is present, the value of a variable at a given observation is connected to the values of that same variable at neighbouring observations:

![](images/clipboard-3880014486.png){fig-align="center" width="500"}

Configuration of areas showing different types of autocorrelation (Nguyen K. et al., 2022)

-   **Positive Spatial Autocorrelation** occurs when similar values of the variable cluster geographically.

-   **Negative Spatial Autocorrelation** arises when dissimilar values are geographically close, indicating that nearby locations tend to differ more than those that are farther apart. This situation often reflects spatial competition.

-   In the **absence of spatial autocorrelation**, the distribution of observations can be considered random.

### **2.2 Cluster and Outlier Analysis**

Cluster and Outlier Analysis can be effectively applied using Local Moran's I, Local Geary's C, Moran scatterplots, and LISA Cluster Maps to identify and understand spatial patterns in data. Here’s how each of these methods can be utilised

#### **2.2.1 Local Moran's I and Local Geary's C**

-   **Local Moran's I**: This statistic assesses local spatial autocorrelation by measuring the degree of similarity of a location's value to those of its neighbours. It identifies clusters of high or low values (hotspots and cold spots) and outliers (areas where a value is significantly different from its neighbours). By calculating Local Moran's I for each location, we can highlight areas with significant spatial dependence, helping to identify regions where interventions may be needed.

-   **Local Geary's C**: Similar to Local Moran's I, Local Geary's C focuses on differences rather than similarities. It quantifies the spatial variation between nearby locations, emphasising dissimilarity. This method can help detect spatial competition, where nearby areas have contrasting values. By using Local Geary's C, we can uncover regions that may experience conflicting trends or behaviours, providing insights into localised dynamics.

#### **2.22. Moran Scatterplot**

-   The **Moran scatterplot** visualises the relationship between the value of a variable at a location and the average value of its neighbours. We can plot scatterplot to represent a location, with the x-axis showing the local mean of neighbouring values and the y-axis showing the local value. 

-   Plots like this can help us in identifying clusters (high-high or low-low) and outliers (high-low or low-high). The scatterplot can reveal spatial patterns that are not immediately obvious.

#### **2.2.3. LISA Cluster Map**

-   A **LISA Cluster Map** visually represents the results of Local Indicators of Spatial Association, indicating the spatial clusters of similar values (hotspots) and outliers. 

-   I will use these maps to quickly identify regions of interest such that areas identified as **hotspots will be marked in red** to signify high values surrounded by high values, while **cold spots will be marked in blue** for low values surrounded by low values. Outliers will be highlighted in contrasting colours.

### **2.3 Emerging Hot Spot Analysis**

There are different methods for analysing spatial patterns and detecting hotspots including spatial autocorrelation and cluster analysis. **Emerging Hot Spot Analysis (EHSA)** is a specific spatio-temporal method used to examine hotspots over a designated **observation period**. It integrates two well-known techniques: the traditional **Getis-Ord Gi\* statistic** for hotspot detection and the **Mann-Kendall test** for assessing monotonic trends over time. The main goal of EHSA is to analyse how hot and cold spots change over time, focusing on whether these areas are increasing in intensity, decreasing, or remaining constant.

## **3. Importing Packages into R**

```{r}
#| include: false
# load_dir <- "data/rds_files/"
# 
# # List all the .rds files in the folder
# rds_files <- list.files(path = load_dir, pattern = "*.rds")
# 
# # Load each .rds file and assign to a variable
# for (rds_file in rds_files) {
#   var_name <- gsub(".rds", "", rds_file)  # Remove the .rds extension
#   assign(var_name, readRDS(paste0(load_dir, rds_file)))  # Load the data
# }
```

Let's load all the required packages for conducting our analysis.

-   [`sf`](https://rdrr.io/github/r-spatial/sf/man/sf-package.html) : provides a standardised way to encode spatial vector data in R environment, facilitating spatial data operations and analysis.
-   [`st`](https://rdrr.io/cran/sf/man/st.html) : create simple features from numeric vectors, matrices, or lists, enabling the representation and manipulation of spatial structures in R.
-   [`tidyverse`](https://www.tidyverse.org/) : a collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structure.
-   [`sfdep`](https://cran.r-project.org/web/packages/spdep/) : for computing spatial weights, global and local spatial autocorrelation statistics. Offers a more streamlined approach with **sf** objects.
-   [`tmap`](https://cran.r-project.org/web/packages/tmap/) : for creating static and interactive visualisations and maps.
-   [`ggplot2`](https://cran.r-project.org/web/packages/ggplot2/) : for creating advanced visualisations, graphics and maps using the Grammar of Graphics.
-   [`knitr`](https://cran.r-project.org/web/packages/spdep/) : for dynamic report generation in R using Literate Programming techniques.
-   [`Kendall`](https://cran.r-project.org/web/packages/Kendall/) : for computing the Kendall rank correlation and Mann-Kendall trend test

```{r}
pacman::p_load(sf, st, tidyverse, lubridate, sfdep, tmap, ggplot2, knitr, Kendall)
```

## **4. Importing Datasets into R**

![](images/clipboard-2233382775.png){fig-align="center" width="528"}

We will be leveraging two datasets in this exercise. The first dataset to be used is Thailand’s provincial boundary is `tha_admbnda_adm1_rtsd_20220121` which exists in **ESRI .shp** **format** and is based on the Thailand geographic coordinate system. This dataset is extracted from [Thailand - Subnational Administrative Boundaries](https://data.humdata.org/dataset/cod-ab-tha?) via the HDX portal.

The second dataset `thai_drug_offenses_2017_2022` consists of aspatial data in a **CSV format** that contains reported cases of drug offences in Thailand from 2017 to 2022. The dataset is extracted from [Thailand Drug Offenses \[2017-2022\]](https://www.kaggle.com/datasets/thaweewatboy/thailand-drug-offenses-2017-2022) in Kaggle.

### **4.1 Importing Geospatial Data**

In this section, `st_read()` of sf package will be used to import `tha_admbnda_adm1_rtsd_20220121` dataset into the R environment. The **`st_transform()`** function below converts the CRS of the **`sf`** object to EPSG:32647 which maps to Thailand's UTM zone, particularly for Western/Central parts.

```{r}
thai_boundary <- st_read(dsn = "data/geospatial",layer = "tha_admbnda_adm1_rtsd_20220121") %>% st_transform(crs = 32647)

# Inspect data
glimpse(thai_boundary)
```

Let’s verify the coordinate reference systems of the `thai_boundary` object to ensure the assignment of the correct CRS value.

```{r}
st_crs(thai_boundary)
```

Before we delve into further data analysis, it is crucial that we first understand the levels of administration that makes up Thailand today. In particular, Thailand has 4 levels of administration, i.e. **level 0 (country), 1 (province), 2 (district),** and **3 (sub-district) boundaries.** Thailand comprises 76 provinces (known as จังหวัด in Thai or changwat in English), along with one special administrative area, Bangkok, the capital. 

-   These provinces function as the main local government units and possess legal personhood. 
-   Each province is subdivided into amphoe (districts), which are further broken down into tambon (sub-districts), representing the next tier of local governance. 
-   **For this analysis, I will only focus on the province administration level.**

We can visualise the structure of our geospatial object as such.

```{r}
#| eval: false
tmap_mode("plot")

# Plot the provinces of Thailand with labels
tm_shape(thai_boundary) +
  tm_borders(col = "black", lwd = 0.3, alpha = 0.6) + 
  tm_polygons()+
  tm_layout(
    main.title = "Provinces of Thailand",
    main.title.size = 1,
    main.title.position = "center",
    legend.show = FALSE,
    frame = FALSE
  ) +
  tm_text("ADM1_EN", size = 0.2)
```

![](images/clipboard-2171615491.png)

### **4.2 Importing Aspatial Data**

In this section, `read_csv()` of **sf** package will be used to import the csv file into the R environment. The output is a R dataframe class containing 5 unique columns of drug offences in Thailand from 2017 - 2022.

```{r}
drug_cases <- read_csv("data/aspatial/thai_drug_offenses_2017_2022.csv")
head(drug_cases)
```

|                        |               |                                                                                |
|----------------|----------------|---------------------------------------|
| **Column Name**        | **Data Type** | **Description**                                                                |
| fiscal_year            | *\<dbl\>*     | The fiscal year during which the drug offenses were recorded.                  |
| types_of_drug_offenses | *\<chr\>*     | The specific type or category of drug offence being reported.                  |
| no_cases               | *\<dbl\>*     | The total number of cases recorded for the specific combination of fiscal year |
| province_th            | *\<chr\>*     | The name of the province in Thailand, written in Thai.                         |
| province_en            | *\<chr\>*     | The name of the province in Thailand, written in English.                      |

### **4.3 Performing a Join on Geometry Column**

Next, we will want to aggregate the total number of drug use cases according to each 77 provinces in Thailand. Here, I use `left_join()` to associate each drug use case to its respective province (i.e. the geometry of the drug case).

```{r}
library(dplyr)

# Step 1: Count rows before the join
initial_row_count <- nrow(drug_cases)

# Step 2: Perform the join and convert to sf
drug_cases <- drug_cases %>%
  left_join(thai_boundary %>% select(geometry, ADM1_EN, ADM1_PCODE), 
            by = c("province_en" = "ADM1_EN")) %>%
  st_as_sf()

# Step 3: Count rows after the join
final_row_count <- nrow(drug_cases)

# Step 4: Check if rows were dropped
if (initial_row_count != final_row_count) {
  cat("Rows were dropped during the join.\n")
  cat("Rows before join:", initial_row_count, "\n")
  cat("Rows after join:", final_row_count, "\n")
} else {
  cat("No rows were dropped during the join.\n")
}

glimpse(drug_cases)
```

## **5. Data Wrangling**

### **5.1 Reduce Data Size**

To reduce the memory load, we can drop the province names in Thai from our aspatial dataset as it is not relevant for this study.

```{r}
drug_cases <- subset(drug_cases, select = c(-province_th))
head(drug_cases)
```

We'll also only retain columns that are most useful from `thai_boundary`.

```{r}
thai_boundary <- subset(thai_boundary, select = c(Shape_Leng, Shape_Area, ADM1_EN, ADM1_PCODE, geometry))
head(thai_boundary)
```

### 5.2 Fixing Missing Values

There are no troublesome rows in the `drug_cases` dataframe.

```{r}
any(is.na(thai_boundary))
#thai_boundary[!complete.cases(st_drop_geometry(thai_boundary)), ]
```

```{r}
any(is.na(drug_cases))
```

#### 5.2.1 Identify Missing Values

We can observe ***192*** reported offences that do not include the **ADM1_PCODE** as seen from how some rows contain empty values 'NA'. We are also getting the **192 empty** `geometry` values as returned from the null test below.

```{r}
drug_cases %>%
  filter(is.na(ADM1_PCODE)) %>%
  select(province_en, ADM1_PCODE)
```

The root cause of this problem lies in how these two province names were incorrectly spelled in the **province_en** column of `drug_casses` , causing an incomplete `left_join()` to be executed.

```{r}
unique(drug_cases[!complete.cases(st_drop_geometry(drug_cases)), ][c('province_en')])
```

```{r}
thai_boundary %>%
  filter(ADM1_EN == "Lop Buri" | ADM1_EN == "Bueng Kan") %>%
  select(ADM1_PCODE, ADM1_EN) %>%
  as_tibble()
```

#### 5.2.2 Fix Missing Values Discovered

Let's fix these NA values by transforming the two province names to their correct names.

-   **Step 1**: Replace Loburi –\> Lop Buri, buogkan –\> Bueng Kan
-   **Step 2:** Replace 'NA' `ADM1_PCDOE` with the correct province code - TH16 and TH38 for Lop Buri and Bueng Kan respectively
-   **Step 3:** Replace the existing geometry column in `drug_cases` with the right geometry

```{r}
# Extract the geometry for Lop Buri
lop_buri_geometry <- drug_cases %>%
  filter(province_en == "Lop Buri") %>%
  reframe(first_geometry = st_union(geometry)) %>%  
  pull(first_geometry)

# Extract the geometry for Bueng Kan
bueng_kan_geometry <- drug_cases %>%
  filter(province_en == "Bueng Kan") %>%
  reframe(first_geometry = st_union(geometry)) %>%
  pull(first_geometry)

# Fix incorrect province names
drug_cases <- drug_cases %>%
  mutate(
    province_en = case_when(
      province_en == "Loburi" ~ "Lop Buri",
      province_en == "buogkan" ~ "Bueng Kan",
      TRUE ~ province_en  
    )
  )

# Fix empty province code
drug_cases <- drug_cases %>%
  mutate(ADM1_PCODE = ifelse(province_en == "Lop Buri" & 
                             is.na(ADM1_PCODE),"TH16", 
                      ifelse(province_en == "Bueng Kan" & 
                             is.na(ADM1_PCODE),"TH38", ADM1_PCODE)))

# Fix empty geometry
thai_boundary_no_geom <- thai_boundary %>%
  select(ADM1_EN, geometry)
drug_cases <- drug_cases %>%
  st_drop_geometry() %>%
  left_join(thai_boundary_no_geom, by = c("province_en" = "ADM1_EN")) 
drug_cases <- st_as_sf(drug_cases)
```

We have successfully removed all NA values found in `drug_cases`.

```{r}
any(is.na(drug_cases))
```

```{r}
# Check the updated drug_cases
drug_cases[!complete.cases(st_drop_geometry(drug_cases)), ]
```

### 5.3 Create New `total_cases` Column

Next, I create a new dataframe `drug_cases_province` to count the total number of cases per province.

```{r}
drug_cases_province <- drug_cases %>%
  group_by(province_en) %>%
  summarise(
    total_cases = sum(no_cases), 
    ADM1_PCODE = first(ADM1_PCODE),              
    geometry = first(geometry), 
    .groups = "drop"                           
  ) %>%
  st_as_sf()

print(drug_cases_province)
```

I will also create a new `drug_cases_province_year` to aggregate the total number of cases for each province and based on each year, regardless of drug offense type.

```{r}
drug_cases_province_year <- drug_cases %>%
  group_by(province_en, fiscal_year) %>%
  summarise(
    fiscal_year = first(fiscal_year),
    total_cases = sum(no_cases), 
    ADM1_PCODE = first(ADM1_PCODE),              
    geometry = first(geometry), 
    .groups = "drop"                           
  ) %>%
  st_as_sf()

print(drug_cases_province_year)
```

## 6. Exploratory Geospatial Data Analysis

### 6.1 Overall Histogram of Drug Cases

I employed the `geom_histogram` function of the `ggplot` package to plot histogram distributions of the spread of the number of drug cases found in Thailand from 2017 to 2022.

Overall, the number of cases appears to be relatively right-skewed with some outliers indicating a significantly high number of drug cases.

```{r}
ggplot(drug_cases, aes(x = no_cases)) + 
  geom_histogram(bins = 20, color = "white", fill = "skyblue3") + 
  labs(x = "Number of Cases", y = "Count", title = "Histogram of Total Drug Cases in Thailand (2017-2022)") +
  theme_minimal() + 
  theme(
    plot.title = element_text(hjust = 0.5, size = 12, face = "bold")
  )
```

### 6.2 Histogram of Drug Cases by Year

Based on each year category, we see that there is a similar pattern of drug cases skewed towards the lower end with an uneven distribution.

```{r}
#| eval: false
library(ggplot2)
library(gridExtra)
library(dplyr)

# Create histogram for each year
drug_cases_2017 <- filter(drug_cases, fiscal_year == 2017)
hist_2017 <- ggplot(drug_cases_2017, aes(x = no_cases)) + 
  geom_histogram(bins = 20, color = "white", fill = "skyblue3") + 
  labs(x = "Number of Cases", y = "Count", title = "Drug Cases in 2017") +
  theme_minimal(base_size = 9) 

drug_cases_2018 <- filter(drug_cases, fiscal_year == 2018)
hist_2018 <- ggplot(drug_cases_2018, aes(x = no_cases)) + 
  geom_histogram(bins = 20, color = "white", fill = "skyblue3") + 
  labs(x = "Number of Cases", y = "Count", title = "Drug Cases in 2018") +
  theme_minimal(base_size = 9)

drug_cases_2019 <- filter(drug_cases, fiscal_year == 2019)
hist_2019 <- ggplot(drug_cases_2019, aes(x = no_cases)) + 
  geom_histogram(bins = 20, color = "white", fill = "skyblue3") + 
  labs(x = "Number of Cases", y = "Count", title = "Drug Cases in 2019") +
  theme_minimal(base_size = 9)

drug_cases_2020 <- filter(drug_cases, fiscal_year == 2020)
hist_2020 <- ggplot(drug_cases_2020, aes(x = no_cases)) + 
  geom_histogram(bins = 20, color = "white", fill = "skyblue3") + 
  labs(x = "Number of Cases", y = "Count", title = "Drug Cases in 2020") +
  theme_minimal(base_size = 9)

drug_cases_2021 <- filter(drug_cases, fiscal_year == 2021)
hist_2021 <- ggplot(drug_cases_2021, aes(x = no_cases)) + 
  geom_histogram(bins = 20, color = "white", fill = "skyblue3") + 
  labs(x = "Number of Cases", y = "Count", title = "Drug Cases in 2021") +
  theme_minimal(base_size = 9)

drug_cases_2022 <- filter(drug_cases, fiscal_year == 2022)
hist_2022 <- ggplot(drug_cases_2022, aes(x = no_cases)) + 
  geom_histogram(bins = 20, color = "white", fill = "skyblue3") + 
  labs(x = "Number of Cases", y = "Count", title = "Drug Cases in 2022") +
  theme_minimal(base_size = 9)

# Arrange all histograms in a grid layout
grid.arrange(hist_2017, hist_2018, hist_2019, hist_2020, hist_2021, hist_2022, nrow = 2)
```

![](images/clipboard-1227396748.png)

### 6.3 Overall Plot of Drug Cases

As such, an ***quantile*** interval will be more suitable in plotting the total number of cases for each province as shown in the tmap output below. Additionally, we can use the default break of **5** to capture a suitable level of granularity across all provinces. For comparison purposes, I will also plot the ***equal*** scale as shown.

```{r}
#| eval: false
# First plot using quantile interval
plot_quantile <- tm_shape(drug_cases_province) +
  tm_polygons("total_cases", 
          style = "quantile", 
          palette = "Blues",
          n = 5,
          title = "Number of Drug Cases") +
  tm_layout(main.title = "Distribution of Drug Cases in Thailand \n by Province (Quantile Interval)",
            main.title.position = "center",
            main.title.size = 0.7,
            main.title.fontface = "bold",
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type = "8star", size = 2, position = c("right", "top")) +
  tm_scale_bar() +
  tm_grid(alpha = 0.2)

# Second plot using equal interval
plot_equal <- tm_shape(drug_cases_province) +
  tm_polygons("total_cases", 
          style = "equal", 
          palette = "Blues",
          n = 5,
          title = "Number of Drug Cases") +
  tm_layout(main.title = "Distribution of Drug Cases in Thailand \n by Province (Equal Interval)",
            main.title.position = "center",
            main.title.size = 0.7,
            main.title.fontface = "bold",
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type = "8star", size = 2, position = c("right", "top")) +
  tm_scale_bar() +
  tm_grid(alpha = 0.2)

# Combine both plots side by side
tmap_arrange(plot_quantile, plot_equal, nrow = 1)
```

![](images/clipboard-234682238.png)

::: {.callout-tip title="Observations"}
Overall, we can observe that the highest number of drug cases are found in the **north-western, central, eastern and southern** provinces of Thailand as seen in the darker regions. Namely..

-   North-west: Chiang Mai, Chiang Rai
-   Central: Chaiyaphum, Khon Kaen and Nakhon-Ratchasima
-   East: Sisaket, Ubon-Ratchathani
-   South: Surat Thani, Nakhon Si Thammarat, Phuket

It is worth noting that smaller provinces are likely to be lighter in shade due to their smaller geographic area.
:::

### 6.4 Plot of Drug Cases by Year

When we further categorise the drug cases by year, we can see that there is an even spread of cases

```{r}
#| eval: false
plot_quantile_year <- tm_shape(drug_cases_province_year) +
  tm_polygons("total_cases", 
          style = "quantile", 
          palette = "Blues") +
  tm_facets(by="fiscal_year", free.coords = FALSE) +
  tm_layout(main.title = "Distribution of Drug Cases in Thailand \n by Province for Each Year (Quantile Interval)",
            main.title.position = "center",
            main.title.size = 0.7,
            main.title.fontface = "bold",
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) 

plot_quantile_year
```

![](images/clipboard-1946072980.png)

::: {.callout-tip title="Observations"}
When the drug cases are visualised by year, we can observe consistent patterns where high drug abuse cases are consistently located at the Southern parts of Thailand. Central Thailand in 2017 showed an average number of drug cases but this increased in the 2018 and continues to increase in the following years till 2022. In 2022, central Thailand faces a high concentration of drug cases which appears to have spread to its neighbouring provinces, particularly with the greatest spread in 2021.
:::

Similar observations can be found when plotting the drug cases using the `knitr` package as shown below.

```{r}
#| eval: false
# Create temporal maps
temporal_maps <- tm_shape(drug_cases_province_year) +  
  tm_polygons("total_cases",  
              palette = "Blues",  
              style = "quantile", 
              title = "Drug Cases") + 
  tm_borders(col = "black", alpha = 0.6) +
  tm_layout(legend.title.size = 1.8,
            legend.text.size = 1.5) +
  tm_facets(along = "fiscal_year", free.coords = FALSE)

# Generate animation
tmap_animation(temporal_maps, filename = "thailand_drugs_temporal.gif", 
               delay = 150, width = 1000, height = 1200)
```

```{r}
# Include the generated GIF
knitr::include_graphics("thailand_drugs_temporal.gif")
```

## 7. Global Measures of Spatial Autocorrelation

The Second Law of Geography articulated by Waldo Tobler in 1970, states that spatial relationships (or correlations) can vary depending on the context and the specific characteristics of different regions. This concept of **spatial non-stationarity** can be effectively measured and analysed using **spatial autocorrelation statistics**.

### 7.1 Methods Used

This section delves into analysing the spatial autocorrelation of our drug cases dataset and assessing how the presence of drug abuse in a province may influence and form clusters around it.

Spatial relationships are characterised by their **multidirectional** and **multilateral** nature, setting them apart from temporal relationships, which are linear and follow a past-present-future sequence. The **codifying process of spatial relationships,** illustrated in the figure below, enables the transformation of complex geographic space into a structured dataset suitable for computer analysis.

![](images/clipboard-550850738.png){fig-align="center" width="389"}

There are multiple approaches to defining spatial neighbours. Two most common methods are:

1.  **Adjacency Measures**: establish links between spatial units that are directly adjacent to one another. In this context, spatial units are considered neighbours if they share a boundary or a point.

2.  **Distance Measures**: selects neighbours based on proximity, where the nearest points to a given spatial unit are identified as neighbours. This approach considers varying distances, enabling a more nuanced understanding of spatial relationships beyond mere adjacency.

    -   **Rook Criterion**: Neighbours are areas that share a common edge via horizontal and vertical connections between spatial units.
    -   **Bishop Criterion**: Neighbours are areas that share a common corner but not necessarily an edge. This approach is similar to the diagonal movements.
    -   **Queen Criterion**: Neighbours are areas that share either an edge or corner, which includes both vertical, horizontal, and diagonal connections.

![](images/clipboard-1656372088.png){fig-align="center" width="454"}

### 7.2 Computing Contiguity Neighbours

I decided to use the Queen criterion in deriving our **neighbour list object** since it covers the most neighbours of the three. To do so, we will utilise the `st_contiguity()` function from the `sfdep` package to create contiguity weight matrices for the study area. This function generates a list of neighbors based on provinces that **share** **contiguous boundaries.** It is worth noting that the function only supports the rook and queen criteria which is suitable for our analysis.

```{r}
thailand_nb_q <- st_contiguity(drug_cases_province$geometry, queen=TRUE)
summary(thailand_nb_q)
```

Each number returned above is an ID assigned to each province from the `st_contiguity()` function. Let's find out the specific provinces highlighted by the summary above!

```{r}
province_ids <- data.frame(
  region_id = seq_along(drug_cases_province$province_en),
  province_en = drug_cases_province$province_en,
  total_cases = drug_cases_province$total_cases
)

province_ids[province_ids$region_id %in% c(17, 48, 69, 71), ]
```

::: {.callout-tip title="Observations"}
-   I can observe a total of 77 provinces (regions) in the dataset with **352 neighbouring links** between the provinces
-   There is **roughly 5.94% non-zero neighbour relationships**. This indicates only a small proportion of total possible connections have neighbours.
-   On average, we can also observe that **each province** has **4.57 neighbouring regions.**
-   **Region** **48** (Phuket province) has **no neighbouring regions**
-   **Region 71** (Trat province) is one of the **least connected provinces** with only 1 neighbouring region
-   **Regions 17** (Khon Kaen province) and **69** (Tak province) are the two provinces with the **most neighbours**, each sharing boundaries with 9 other provinces
:::

### 7.3 **Computing Row-Standardised Weight Matrix**

Next, I attempt to calculate spatial weights but the **isolated region (48)** is causing issues as spatial weights calculations require all regions to have neighbors.

To resolve the issue caused by the isolated region, I will use the `allow_zero = TRUE` option when calculating spatial weights, which will assign zero as a lagged value to allow the analysis to proceed despite isolated regions.

```{r}
thailand_wt <- st_weights(thailand_nb_q, style = "W", allow_zero = TRUE)
```

We will mutate the newly created neighbour list object `thailand_nb_1` and weight matrix `thailand_wt` into our existing `drug_cases_province`. This results in a newly created object called `wm_1`.

```{r}
wm_q <- drug_cases_province %>%
  mutate(nb = thailand_nb_q,
         wt = thailand_wt,
         .before = 1) 

# Inspect
wm_q
```

### 7.4 Visualising Contiguity Weights

Let's also visualise the Queen's neighbour map. Here, we retrieve the centroid coordinates of each province by combining the longitude and latitude into a single object via `st_centroid()`. The outputs of the coordinate looks correct as shown.

```{r}
# Extract centroid geometries
centroids <- st_centroid(drug_cases_province)
head(centroids)
```

Now, let's plot the contiguity weights using the Queen's method for all provinces.

```{r}
#| eval: false
# Plot all regions (showing the boundaries)
plot(drug_cases_province$geometry, border = "lightgrey", main = "Queen's Contiguity Weights (Including All Regions)")

# Loop through each region and plot neighbors if they exist
for (i in seq_along(thailand_nb_q)) {
  # Check if the region has neighbors
  if (length(thailand_nb_q[[i]]) > 0) {
    for (neighbor in thailand_nb_q[[i]]) {
      current_coords <- st_coordinates(centroids[i, ])
      neighbor_coords <- st_coordinates(centroids[neighbor, ])
      
      # Create a LINESTRING directly from the two centroid coordinates
      combined_geom <- matrix(c(current_coords[1], current_coords[2],
                                 neighbor_coords[1], neighbor_coords[2]),
                              ncol = 2, byrow = TRUE)
      
      # Draw lines between the current region and its neighbour
      lines(combined_geom, col = "blue")
    }
  }
}
```

![](images/Untitled design (1).png){fig-align="center"}

::: {.callout-tip title="Observations"}
We cam observe that most connections between the centroids of each province is found at the **lower central regions** of Thailand which shows signs of higher interactivity between provinces here. Surprisingly, there are fewer connecting relationships between provinces in the central parts of Thailand.
:::

### 7.5 Global *Moran's I*

Moran’s I is a inferential static measure of the correlation between a variable and the values of its neighbouring regions to **determine statistical significance**. It reflects the **extent** to which **individual features deviate** from the **overall values** in the study area, assessing the **similarity** between each region and its neighbours, and averages these evaluations.

To examine spatial autocorrelation, we must test the following hypotheses:

-   **Null Hypothesis (H0)**: This states that there is either ***no*** spatial autocorrelation (H0) or that ***negative*** spatial autocorrelation exists (H0).
-   **Alternative Hypothesis (H1)**: This suggests that ***positive*** spatial autocorrelation is present.

The values of Moran’s I typically range from -1 to 1.

-   **-1** is perfect clustering of dissimilar values (perfect dispersion).
-   **0** is no autocorrelation (perfect randomness.)
-   **+1** indicates perfect clustering of similar values (the opposite of dispersion).

#### 7.5.1 Computing Global *Moran's I*

I will employ the [`global_moran()`](https://sfdep.josiahparry.com/reference/global_moran) function to compute the Moran’s I value which outputs a tibble dataframe. The `zero.policy` has been set to `TRUE` to allow the function to appropriately handle areas with no neighbours.

```{r}
moranI <- global_moran(wm_q$total_cases,
                       wm_q$nb,
                       wm_q$wt, 
                       zero.policy = TRUE)
glimpse(moranI)
```

::: {.callout-tip title="Observations"}
Based on the outputs...

-   The **Moran's I** value of `0.119` suggests a slight positive spatial autocorrelation, indicating clustering of similar values (e.g., areas with similar drug case counts).

-   The **K** value of `15.8` indicates that each region, on average, has about 15.8 neighbours, which is a moderate level of connectivity among the regions being analysed.
:::

#### 7.5.2 Global *Moran's I* Test

The Global Moran’s I test, which can be performed using the `global_moran_test()` function from the `sfdep` package, is a tool for assessing spatial autocorrelation. The main objective of this test is to **ascertain the presence of systemic spatial variations of drug abuse cases**. In other words, how the number of drug cases in each province vary according to its surrounding provinces compared to that under spatial randomness.

For this analysis, we will specify `alternative = "greater"` in line with our alternative hypothesis.

```{r}
global_moran_test(wm_q$total_cases,
                       wm_q$nb,
                       wm_q$wt,
                       zero.policy = TRUE,
                       alternative = "greater")
```

::: {.callout-tip title="Observations"}
The calculated Moran I statistic returns a positive value of **0.118,** suggesting **positive spatial autocorrelation** and a tendency for similar values to be **more clustered together** than would be expected by chance. Hence, the spatial distribution of drug cases is not random.

The standard deviation (or z-score)of the observed Moran I statistic is **1.8848 s.d. away from the expected value** (which is typically 0 under the null hypothesis). The positive s.d. indicates that the observed clustering is stronger than what would be expected under the null hypothesis.

Since the **p-value of 0.02973** \< **alpha value of 0.05**, assuming a 95% confience interval, there is **statistically significant evidence** to reject the null hypothesis (which posits that there is no spatial autocorrelation) in favour of the alternative hypothesis, confirming that positive spatial autocorrelation is present in the data.
:::

#### **7.5.3 Performing Global *Moran’s I*** Permutation Test

From a frequentist approach, sampling the p-value once is not sufficient for determining the long-run behaviour of estimators and tests. Hence, let us strengthen our findings by repeated sampling, that is to perform **Monte Carlo simulation** and then, observe the results.

```{r}
set.seed(1234)
gmoran_MC <- global_moran_perm(wm_q$total_cases,
                  wm_q$nb,
                  wm_q$wt,
                  zero.policy = TRUE,
                  nsim = 999)
gmoran_MC
```

::: callout-note
It is always good practice to use `set.seed()` before performing simulation. This is to ensure that the computation is reproducible.
:::

::: {.callout-tip title="Observations"}
After 1000 simulations, our observed result confirms that the p-value is indeed **smaller than the alpha value of 0.05** and the **Moran I statistic is \> 0**. Hence, we can **reject the H0** in favour of H1, meaning that the results of `global_moran_test()` test is stable and statistically significant, and spatial distribution of drug cases resemble clustering distribution patterns.
:::

Now, we can analyse the spatial distribution of drug cases in a histogram and its summary statistics.

```{r}
#| eval: false
ggplot() + 
  aes(gmoran_MC$res[1:999]) + 
  geom_histogram(colour="black", fill="skyblue3") + 
  geom_vline(aes(xintercept = mean(gmoran_MC$res)), color = 'red') +
  labs(title = "Histogram of Simulated Moran's I For Thailand's Drug Cases",
       x = "Simulated Moran's I",
       y = "Occurences") +
  theme_minimal()+ 
  theme(
    plot.title = element_text(hjust = 0.5, size = 12, face = "bold")
  )
```

![](images/clipboard-3719881788.png)

```{r}
# Summary Statistics
summary(gmoran_MC$res[1:999])
```

::: {.callout-tip title="Observations"}
We can confirm that the **observed Moran I statistic** **(0.11775)** is **higher** than the **median (−0.01834)** and **mean (−0.01352)** of the simulated values. This suggests that the observed spatial pattern is more clustered than what would be expected if the values were randomly distributed.
:::

### 7.6 Global Geary's C Test

In practice, when analysing spatial data, it is often recommended to use both Geary’s C and Moran’s I to gain a more comprehensive understanding of spatial patterns. However, **Geary's C** can **often fail to detect localised clustering** compared to other spatial autocorrelation tests like Moran's I.

-   **Geary’s C is more sensitive to local dissimilarities** between individual pairs of neighbouring areas rather than overall clustering, which makes it less effective at identifying larger-scale spatial structures or clusters.

-   **Moran’s I is better at identifying global patterns** of clustering, where areas with similar values are grouped together in broader spatial clusters.

Nonetheless, let's explore what Geary's C results look like for us.

#### 7.6.1 Computing Global *Geary's C*

**Geary's C test** is developed by Geary (1954), which examines the intensity of a specific characteristic in spatial objects using a weight matrix. It can be performed using `global_c_test()` of the `sfdep` package in R, similar to how we conducted the Global Moran's I test for evaluating spatial autocorrelation.

```{r}
global_c(
  wm_q$total_cases, 
  wm_q$nb, 
  wm_q$wt,
  allow_zero = TRUE
)
```

::: {.callout-tip title="Observations"}
The Geary's C statistic returned is `0.9879` which, unlike the results returned by *Moran's I,* suggests a **weak positive spatial autocorrelation** since it is very close to **1**, indicating little to no spatial autocorrelation. As mentioned, Geary's C tends to focus on local clusters which might miss larger clusters.
:::

#### 7.5.2 Global *Geary C's* Test

Let us perform the Geary C's Test which can be implemented using `global_c_test()` from the `sfdep` package.

```{r}
global_c_test(wm_q$total_cases,
                  wm_q$nb,
                  wm_q$wt,
                  allow_zero = TRUE,
                  alternative = "greater")
```

::: {.callout-tip title="Observations"}
After performing the Geary C test, we can observe that...

-   **Geary’s C statistic** is close to **1**, suggesting **little or no spatial autocorrelation**.

-   The **p-value of 0.41** indicates that the observed pattern is **not significantly different from random**.

-   Therefore, the data does not show strong spatial clustering or dispersal, and the spatial distribution of values is likely random.
:::

#### **7.5.3 Performing Global *Geary's C*** Permutation Test

```{r}
ggeary_MC <- global_c_perm(wm_q$total_cases,
                  wm_q$nb,
                  wm_q$wt,
                  allow_zero = TRUE,
                  alternative = "greater",
                  nsim = 999)
ggeary_MC
```

We can see that the distribution of drug cases resulting from the Geary's C permutation test has a **much higher** **mean (0.9851)** and **median (0.9860) t**han what was outputted by the Global Moran's I test. Likewise, the observed Geary's C statistics of 0.97488 suggests that the data does not show strong clustering/dispersed, but is random.

```{r}
#| eval: false
ggplot() + 
  aes(ggeary_MC$res[1:999]) + 
  geom_histogram(colour="black", fill="skyblue3") + 
  geom_vline(aes(xintercept = mean(ggeary_MC$res)), color = 'red') +
  labs(title = "Histogram of Simulated Geary's C For Thailand's Drug Cases",
       x = "Simulated Geary's C",
       y = "Occurences") +
  theme_minimal()+ 
  theme(
    plot.title = element_text(hjust = 0.5, size = 12, face = "bold")
  )
```

![](images/clipboard-1581274930.png)

```{r}
# Summary Statistics
summary(ggeary_MC$res[1:999])
```

::: {.callout-tip title="Observations"}
As shown, Geary’s C indeed indicate randomness since it doesn’t detect the **global pattern** of spatial clustering, even when such a pattern is present. This local focus of Geary's C could make it **miss larger clusters** and conclude that the spatial distribution is more random than it actually is.
:::

## 8. Local Indicators of Spatial Association (LISA)

Previously, we used *Global Moran's I* and *Geary's C* in which we discovered whether spatial clustering exists across the whole Thailand region.

However, I would also like to perform local spatial autocorrelation to identify specific areas of clustering **at a local level** using LISA methods (Anselin, 1995). If these methods detect significant local clusters, it can help confirm that there are indeed clustered patterns that Geary’s C might have missed.

### 8.1 Local *Moran's I~i~*

#### 8.1.1 Computing Local *Moran's I~i~*

**Local Moran’s I~i~** is an extension of **Global Moran’s I**, designed to identify **local clusters** and **spatial outliers** within a dataset. **Local Moran’s I~i~** provides a measure of autocorrelation at individual locations, identifying where significant clustering or outliers exist.

Let's utilise the `local_moran()` function of **sfdep** to handle the computations. Once again, we'll set `zero.policy` to **TRUE** to allow the analysis to continue despite the one province with 0 neighbours.

```{r}
lisa <- wm_q %>% 
  mutate(local_moran = local_moran(total_cases, nb, wt, 
                                   zero.policy = TRUE, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)

# Inspect
lisa
```

::: {.callout-tip title="How to read the table output"}
The output from the `local_moran()` function is an `sf` data frame that includes the following columns: `ii, eii, var_ii, z_ii, p_ii, p_ii_sim,` and`p_folded_sim.`

-   **ii**: This represents the local Moran statistic.
-   **eii**: This denotes the expected value of the local Moran statistic; for `localmoran_perm`, it corresponds to the means from the permutation samples.
-   **var_ii**: This indicates the variance of the local Moran statistic; for `localmoran_perm`, it reflects the standard deviations from the permutation samples.
-   **z_ii**: This is the standard deviation of the local Moran statistic; for `localmoran_perm`, it is calculated based on the means and standard deviations from the permutation samples.
-   **p_ii**: This is the p-value for the local Moran statistic, derived using the `pnorm()` function; for `localmoran_perm`, it utilizes standard deviations based on the means and standard deviations from the permutation samples.
-   **p_ii_sim**: For `localmoran_perm()`, this represents the rank of the observed statistic in relation to a uniform distribution for \[0, 1\] p-values, using the specified alternative hypothesis.
-   **p_folded_sim**: This reflects the simulation of ranked p-values within the folded range of \[0, 0.5\], based on a specific implementation found in the [GitHub repository](https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205bcadcbecc5e061/esda/crand.py#L211-L213).
:::

#### 8.1.2 Visualising Local *Moran's I~i~*

To ease our analysis, an approach we can take is to plot the local Moran's I values across to visualise the observed values across each province. We'll use a choropleth map from the `tmap` package to analyse the spatial patterns.

```{r}
#| eval: false
tm_shape(lisa) +
  tm_fill("ii", 
          palette = c("#B3EBF2","green1","orange","red"),
          title = "Local Moran's I",
          midpoint = NA,
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_borders(col = "black", alpha = 0.6) +
  tm_layout(main.title = "Province-Level Spatial Autocorrelation \nof Drug Cases in Study Area (Thailand)",
            main.title.position = "center",
            main.title.size = 0.7,
            main.title.fontface = "bold",
            legend.title.size = 0.4,
            legend.text.size = 0.4,
            legend.hist.size = 0.3,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type = "8star", text.size = 0.7, size = 2, position = c("RIGHT", "TOP")) +
  tm_scale_bar(position = c("LEFT", "BOTTOM"), text.size = 0.7) +
  tm_grid(labels.size = 0.5, alpha = 0.2)
```

![](images/8.1.2.png){fig-align="center" width="500"}

::: {.callout-tip title="Observations"}
The local spatial autocorrelation using *Moran's I* outputs a total of **4 different regions**, each with a different range of Moran's I value.

-   Provinces in ***blue*** indicate a local Moran's I value ranging from -1 to 0 with **low-high** spatial association or **no similarity** with its neighbours.
    -   These province are outliers since they exhibit **lower intensity of drug cases** **compared to its surrounding provinces** where drug cases are higher in intensity
-   Provinces in ***green, orange and red*** has a local Moran's I value ranging from 0 to 3 with **high-high** spatial association.
    -   These provinces tend to exhibit a high incidence of drug cases and are surrounded by other provinces with **similarly high values.**
    -   Samut Prakan province **(in red)** shows the **strongest clustering effect** i.e. it is strongly associated with its high drug-cases neighbours.
    -   Followed by Nakhon Si Thammarat **(in orange)** which shows the 2nd strongest clustering effect.

Overall, the spatial autocorrelation of drug cases is a prevalent and widespread issue across provinces in Thailand. The two provinces, Samut Prakan and Nakhon Si Thammarat, suggests to be **high-risk regions** for the spread of drug cases.

However, for a complete understanding of these spatial autocorrelation patterns, we are required to evaluate the **statistical significance** associated with each Local Moran's I value.
:::

#### 8.1.3 Visualising Local *Moran's I~i~* P-value

As mentioned in the section above, we shall not hastily conclude the clustering results observed. Instead, let us also evaluate whether the observed clustering (high-high or low-low) is **statistically significant** or **could have occurred by chance**. Hence, we can derive the p-values from Local Moran's I by using the `p_ii_sim` field to determine statistical signficance across provinces.

```{r}
#| eval: false
# Remove lisa record with 0 neighbours
lisa_clean <- lisa %>% filter(!is.na(p_ii_sim))

tm_shape(lisa_clean) +
  tm_fill("p_ii_sim", 
          palette = c("lightyellow1","green1","orange","orange4","red"),
          title = "p-value",
          midpoint = NA,
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_borders(col = "black", alpha = 0.6) +
  tm_layout(main.title = "Statistical Signifance of Spatial Autocorrelation\n of Drug Cases in Study Area (Thailand)",
            main.title.position = "center",
            main.title.size = 0.6,
            main.title.fontface = "bold",
            legend.title.size = 0.4,
            legend.text.size = 0.4,
            legend.hist.size = 0.3,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type = "8star", text.size = 0.7, size = 2, position = c("RIGHT", "TOP")) +
  tm_scale_bar(position = c("LEFT", "BOTTOM"), text.size = 0.7) +
  tm_grid(labels.size = 0.5, alpha = 0.2)
```

![](images/8.1.3.png){fig-align="center" width="500"}

::: {.callout-tip title="Observations"}
From the map above, not every province exhibits statistically significant Local *Moran I's* value (i.e. p-value \< 0.05)
:::

#### 8.1.4 Visualising Statistically Significant Local *Moran's I~i~*

With that said, it will be interesting to switch our focus to provinces that display statistically significant local *Moran's I* values. To execute this, I will attempt to remove all local *Moran's I* values with **p-values greater than 0.05**. Subsequently, I will use the `tmap` function to plot the choropleth of statistically significant local spatial autocorrelation on the map of Thailand.

```{r}
#| eval: false
lisa_sig <- lisa  %>%
  filter(p_ii_sim < 0.05)

tm_shape(lisa)+
  tm_polygons() +
  tm_borders(col = "black", alpha = 0.6)+
tm_shape(lisa_sig) +
  tm_fill("ii", 
          palette = c("#B3EBF2","lightyellow","green3","orange","orange4","orangered2","red"),
          title = "Local Moran's I (p-value < 0.05)",
          midpoint = NA,
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_borders(col = "black", alpha = 0.6) +
  tm_layout(main.title = "Statistical Signifance of Spatial Autocorrelation\n of Drug Cases in Study Area (Thailand)",
            main.title.position = "center",
            main.title.size = 0.6,
            main.title.fontface = "bold",
            legend.title.size = 0.4,
            legend.text.size = 0.4,
            legend.hist.size = 0.3,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type = "8star", text.size = 0.7, size = 2, position = c("RIGHT", "TOP")) +
  tm_scale_bar(position = c("LEFT", "BOTTOM"), text.size = 0.7) +
  tm_grid(labels.size = 0.5, alpha = 0.2)
```

![](images/8.1.4.png){fig-align="center" width="500"}

::: {.callout-tip title="Observations"}
**Low-high spatial association**

-   The Nonthaburi province indicated in blue (southern part of central Thailand) suggests to have a **low-high** spatial association as shown from its negative local *Moran's I* values ranging from **-0.5 to 0.**

**High-high spatial association**

-   Central provinces **(in yellow)**, Phitsanulok and Nakhon Sawan, show a low positive local *Moran's I* value of 0 to 0.5, indicating some levels of clustering.

-   Chainat province **(in green)**, located in Western Thailand has a local *Moran's I value* between 1 and 1.5

-   Samut Prakan province **(in red)** has the strongest association with its neighbours in which, like itself, its neighbours also exhibit high drug cases.
:::

```{r}
#| include: false
# save_dir <- "data/rds_files/"
# if (!dir.exists(save_dir)) {
#   dir.create(save_dir)
# }
# 
# vars <- ls()
# 
# # Save each variable as an RDS file
# for (var in vars) {
#   saveRDS(get(var), file = paste0(save_dir, var, ".rds"))
# }
```
