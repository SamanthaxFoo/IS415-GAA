---
title: "Hands-on Exercise 4"
subtitle: "Network Constrained Spatial Point Patterns Analysis"
author: "Foo Jia Yi Samantha"
date-modified: 08/28/2024
date: 08/28/2024
execute: 
  eval: true
  echo: true
  freeze: true
---

```{=html}
<button>Hands-on Exercise</button> <button>R</button> <button>sf</button> <button>tmap</button><button>spNetwork</button><button>NKDE</button>
```
## 1. Getting Started

In this exercise, I will be exploring more advanced methods of spatial point pattern analysis - specifically on **Network constrained Spatial Point Patterns Analysis (NetSPAA).** This is a continuation from the basic spatial point pattern analysis conducted in [Hands-on Exercise 3](https://is415-samanthafoo.netlify.app/hands-on_ex/hands-on_ex3/hands-on_ex3).

In this hands-on exercise, I will leverage appropriate functions of **spNetwork** package:

-   to derive **network kernel density estimation (NKDE)**, and
-   to perform network G-function and k-function analysis

> **💡 What is NetSPAA?:** NKDE is a collection of spatial point patterns analysis methods special developed for analysing spatial point event occurs on or alongside network. The spatial point event can, for instance, be locations of traffic accident or childcare centre. The network, on the other hand can be a road network or river network

### 2.1 Importing Libraries into R

In this exercise, we will use the following R packages:

-   [spNetwork](https://cran.r-project.org/web/packages/spNetwork/index.html), which provides functions to perform Spatial Point Patterns Analysis such as kernel density estimation (KDE) and K-function on network. It also can be used to build spatial matrices (‘listw’ objects like in ‘spdep’ package) to conduct any kind of traditional spatial analysis with spatial weights based on reticular distances.

-   [sf](https://r-spatial.github.io/sf/index.html) package provides functions to manage, processing, and manipulate **Simple Features**, a formal geospatial data standard that specifies a storage and access model of spatial geometries such as points, lines, and polygons.

-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html) which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using [leaflet](https://leafletjs.com/) API.

Use the code chunk below to install and launch the four R packages.

Now, let's install and load these packages in RStudio.

```{r}
pacman::p_load(sf, spNetwork, tmap, tidyverse)
```

### 2.2 Download Data and Set Up Folders

In this study, we will analyse the spatial distribution of childcare centre in [Punggol planning area](https://en.wikipedia.org/wiki/Punggol). For the purpose of this study, two geospatial data sets will be used ESRI shapefile format). They are:

-   ***Punggol_St***, a line features geospatial data which store the road network within Punggol Planning Area.
-   ***Punggol_CC***, a point feature geospatial data which store the location of childcare centres within Punggol Planning Area.

This is the file structure for containing the data files that I have extracted.

![](images/clipboard-2626479234.png){width="241"}

## 3. Import Data Sets into R

The code chunk below uses `st_read()` of **sf** package to important Punggol_St and Punggol_CC geospatial data sets into RStudio as sf data frames.

```{r}
network <- st_read(dsn="chap07/data/geospatial", 
                   layer="Punggol_St")

childcare <- st_read(dsn="chap07/data/geospatial",
                     layer="Punggol_CC")
```

Now, let's examine the content of network and childcare simple features objects.

```{r}
# Examine the childcare sf data.frame
childcare

# Examine the network sf data.frame
network
```

## 4. Visualise the Geospatial Data

Before we jump into the analysis, it is a good practice to visualise the geospatial data. There are at least two ways to visualise the geospatial data. One way is by using **`plot()`** of Base R as shown in the code chunk below.

```{r}
plot(st_geometry(network))
plot(childcare,add=T,col='red',pch = 19)
```

To visualise the geospatial data with higher cartographic quality and in a more interactive manner, the mapping function of **tmap** package can be used as shown below.

```{r}
# View interactive and higher quality version of map
tmap_mode('view')
tm_shape(childcare) + 
  tm_dots() + 
  tm_shape(network) +
  tm_lines()

# Switch tmap mode back to plot
tmap_mode('plot')
```

## 6. Network KDE (NKDE) Analysis

In this section, we will perform NKDE analysis by using appropriate functions provided in **spNetwork** package.

### **6.1 Preparing the lixels objects**

Before computing NKDE, the SpatialLines object need to be cut into lixels with a specified minimal distance. This task can be performed by using with [lixelize_lines()](https://jeremygelb.github.io/spNetwork/reference/lixelize_lines.html) of **spNetwork** as shown in the code chunk below.

```{r}
lixels <- lixelize_lines(network, 
                         700, 
                         mindist = 375)
```

::: callout-note
**Key learning takeaway**

-   The length of a lixel, *lx_length* is set to **700m**, and
-   The minimum length of a lixel, *mindist* is set to **375m**.

**Other notes:**

After cutting, if the length of the **final lixel \< minimum distance**, then it is added to the previous lixel. If **NULL**, then mindist = maxdist/10. Segments that are already shorter than the minimum distance are not modified!

There is another function called ***lixelize_lines.mc()*** which provides multicore support.
:::

### 6.2 **Generating Line Centre Points**

Next, ***lines_center()*** of **spNetwork** will be used to generate a SpatialPointsDataFrame (i.e. samples) with line centre points as shown in the code chunk below.

```{r}
samples <- lines_center(lixels) 
```

> 💡 **Note:** The position of points depends on the length of the line.

### 6.3 **Performing NKDE**

We are ready to computer the NKDE by using the code chunk below.

```{r}
densities <- nkde(network, 
                  events = childcare,
                  w = rep(1, nrow(childcare)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, 
                  sparse = TRUE,
                  verbose = FALSE)
```

To understand the code above better:

::: panel-tabset
## kernel_name

The**`kernel_name`** argument indicates that **quartic** kernel is used. There are possible kernel methods supported by spNetwork: triangle, gaussian, scaled gaussian, tricube, cosine ,triweight, epanechnikov or uniform.

## method

The **`method`** argument indicates that **simple** method is used to calculate the NKDE. Currently, **spNetwork** support three popular methods, they are:

-   **method=“simple”**. This first method was presented by Xie et al. (2008) and proposes an intuitive solution. The distances between events and sampling points are replaced by network distances, and the formula of the kernel is adapted to calculate the density over a linear unit instead of an areal unit.

-   **method=“discontinuous”**. The method is proposed by Okabe et al (2008), which equally “divides” the mass density of an event at intersections of lixels.

-   **method=“continuous”.** If the discontinuous method is unbiased, it leads to a discontinuous kernel function which is a bit counter-intuitive. Okabe et al (2008) proposed another version of the kernel, that divide the mass of the density at intersection but adjusts the density before the intersection to make the function continuous.
:::

### 6.4 Visualising **NKDE**

Before we can visualise the NKDE values, code chunk below will be used to insert the computed density values (i.e. densities) into ***samples*** and ***lixels*** objects as ***density*** field.

```{r}
samples$density <- densities
lixels$density <- densities
```

Since **svy21** projection system is in **metres**, the computed density values are very small i.e. 0.0000005. Hence, I'll rescale the density values from number of events per **metre** to number of events per **kilometre**.

```{r}
# Rescaling to help the mapping
samples$density <- samples$density*1000
lixels$density <- lixels$density*1000
```

The code below uses appropriate functions of tmap package to prepare interactive and high cartographic quality map visualisation.

```{r}
tmap_mode('view')
tm_shape(lixels)+
  tm_lines(col="density")+
tm_shape(childcare)+
  tm_dots()

# Convert map mode bacck to plot
tmap_mode('plot')
```

> 🔎 **Observations:** The interactive map above effectively reveals road segments (darker color) with relatively higher density of childcare centres than road segments with relatively lower density of childcare centres (lighter color)

## 7. **Network Constrained G- and K-Function Analysis**

In this section, we are going to perform Complete Spatial Randomness (CSR) test by using **`kfunctions()`** of **spNetwork** package.

> **💡 The null hypothesis is defined as:**
>
> **H0:** The observed spatial point events (i.e distribution of childcare centres) are uniformly distributed over a street network in Punggol Planning Area.

The CSR test is based on the assumption of the **binomial point process** which implies the hypothesis that the childcare centres are randomly and independently distributed over the street network.

> **💡 If this hypothesis is rejected:**\
> We may infer that the distribution of childcare centres are **spatially interactin**g and **dependent on each other**; as a result, they may form non-random patterns.

```{r}
kfun_childcare <- kfunctions(network, 
                             childcare,
                             start = 0, 
                             end = 1000, 
                             step = 50, 
                             width = 50, 
                             nsim = 50, 
                             resolution = 50,
                             verbose = FALSE, 
                             conf_int = 0.05)
```

> 💡 **To understand the arguments used above**
>
> -   **lines**: A SpatialLinesDataFrame with the sampling points. The geometries must be a SpatialLinesDataFrame (may crash if some geometries are invalid).
> -   **points**: A SpatialPointsDataFrame representing the points on the network. These points will be snapped on the network.
> -   **start**: A double, the start value for evaluating the k and g functions.
> -   **end**: A double, the last value for evaluating the k and g functions.
> -   **step**: A double, the jump between two evaluations of the k and g function.
> -   **width**: The width of each donut for the g-function.
> -   **nsim**: An integer indicating the number of Monte Carlo simulations required. In the above example, 50 simulation was performed. **Note:** most of the time, more simulations are required for inference
> -   **resolution**: When simulating random points on the network, selecting a resolution will reduce greatly the calculation time. When resolution is null the random points can occur everywhere on the graph. If a value is specified, the edges are split according to this value and the random points are selected vertices on the new network.
> -   **conf_int**: A double indicating the width confidence interval (default = 0.05).

Let's visualise the ggplot2 object of the k-funcition:

```{r}
# Visualise the ggplot2 object
kfun_childcare$plotk
```

> 🔎 **Observations:**
>
> -   The **blue line** is the empirical network K-function of the childcare centres in Punggol planning area.
> -   The **gray** **envelop** represents the results of the 50 simulations in the interval 2.5% - 97.5%.
> -   Since the blue line, between the distance of 250m-400m, are below the gray area, we can infer that the **childcare centres in Punggol planning area** resemble regular pattern at the **distance of 250m-400m.**
